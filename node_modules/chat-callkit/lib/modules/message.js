"use strict";

exports.__esModule = true;
exports.sendTextMsg = exports.sendCMDMsg = exports.sendAlerting = exports.cancelCall = exports.answerCall = exports.addListener = void 0;

var _callManager = require("./callManager");

require("./utils");

var _redux = _interopRequireDefault(require("../redux"));

var _reducer = require("../redux/reducer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var manager = {};

var sendTextMsg = function sendTextMsg(chatType, to, message, ext) {
  var option = {
    chatType: chatType,
    type: "txt",
    to: to,
    msg: message,
    ext: ext
  };

  var msg = _callManager.WebIM.message.create(option);

  _callManager.WebIM.conn.send(msg);

  if (ext.type === 0 || ext.type === 1) {
    var _dispatch = _redux["default"].dispatch;
    _callManager.WebIM.rtc.timer = setTimeout(function () {
      console.warn('caller timeout');

      _callManager.callManager.hangup('timeout', true);

      _dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
    }, 30000);
  }
};

exports.sendTextMsg = sendTextMsg;

var sendCMDMsg = function sendCMDMsg(chatType, to, message, ext) {
  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);
  msg.set({
    to: to,
    action: 'rtcCall',
    ext: ext,
    success: function success(id, serverMsgId) {
      dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
    },
    fail: function fail(e) {
      console.warn("callee send alert fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);
}; // callee


exports.sendCMDMsg = sendCMDMsg;

var sendAlerting = function sendAlerting(to, calleeDevId, callId) {
  var getState = _redux["default"].getState,
      dispatch = _redux["default"].dispatch;

  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);

  if (!to) {
    return;
  }

  msg.set({
    to: to,
    action: 'rtcCall',
    ext: {
      action: 'alert',
      calleeDevId: _callManager.WebIM.conn.context.jid.clientResource,
      callerDevId: calleeDevId,
      callId: callId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora'
    },
    success: function success(id, serverMsgId) {
      dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
    },
    fail: function fail(e) {
      console.warn("callee send alert fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);

  _callManager.WebIM.rtc.timer = setTimeout(function () {
    console.warn('callee timeout');

    _callManager.callManager.hangup('timeout');

    dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
  }, 30000);
}; // caller


exports.sendAlerting = sendAlerting;

var confirmRing = function confirmRing(to, calleeDevId, callerDevId, callId) {
  var getState = _redux["default"].getState,
      dispatch = _redux["default"].dispatch;
  var confr = getState().confr;
  var currentCallId = confr.callId;
  var status = true;

  if (callId !== currentCallId) {
    console.warn('not current call', callId, currentCallId);
    status = false;
  }

  if (getState().callStatus > _reducer.CALLSTATUS.receivedConfirmRing && ![2, 3].includes(confr.type)) {
    //in call
    console.warn('caller is busy', confr);
    status = false;
  } // if (confr.calleeDevId && confr.calleeDevId != calleeDevId){
  // 	console.warn('calleeDevId is different')
  // 	status = false
  // }


  if (callerDevId !== _callManager.WebIM.conn.context.jid.clientResource) {
    console.warn('caller device is different');
    return;
  }

  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);
  msg.set({
    to: to,
    action: 'rtcCall',
    ext: {
      action: 'confirmRing',
      status: status,
      callerDevId: _callManager.WebIM.conn.context.jid.clientResource,
      calleeDevId: calleeDevId,
      callId: callId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora'
    },
    success: function success(id, serverMsgId) {
      if (status) {
        if (getState().callStatus < _reducer.CALLSTATUS.confirmRing) {
          dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.confirmRing));
        }
      }
    },
    fail: function fail(e) {
      console.warn("caller send confirmRing fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);
}; // callee


var answerCall = function answerCall(result, info) {
  var getState = _redux["default"].getState,
      dispatch = _redux["default"].dispatch;
  info = info || {};

  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);
  var currentCallId = info.currentCallId || getState().confr.callId;
  var callerDevId = info.callerDevId || getState().confr.callerDevId;
  var to = info.to || getState().confr.callerIMName;
  msg.set({
    to: to,
    action: 'rtcCall',
    ext: {
      action: 'answerCall',
      result: result,
      // busy/accept/refuse
      callerDevId: callerDevId,
      calleeDevId: _callManager.WebIM.conn.context.jid.clientResource,
      callId: currentCallId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora'
    },
    success: function success(id, serverMsgId) {},
    fail: function fail(e) {
      console.warn("callee send answerCall fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);
}; // caller


exports.answerCall = answerCall;

var confirmCallee = function confirmCallee(to, calleeDevId, result) {
  var getState = _redux["default"].getState,
      dispatch = _redux["default"].dispatch;

  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);
  var confr = getState().confr;
  var currentCallId = confr.callId;

  if (!confr.calleeDevId && ![2, 3].includes(confr.type)) {
    dispatch((0, _reducer.updateConfr)({
      to: confr.confrName,
      ext: {
        channelName: confr.channel,
        token: confr.token,
        type: confr.type,
        callerDevId: confr.callerDevId,
        calleeDevId: calleeDevId,
        callId: confr.callId,
        calleeIMName: confr.calleeIMName,
        callerIMName: confr.callerIMName
      }
    }));
  } else if (confr.calleeDevId != calleeDevId && ![2, 3].includes(confr.type)) {
    result = 'refuse';
  }

  msg.set({
    to: to,
    action: 'rtcCall',
    ext: {
      action: 'confirmCallee',
      result: result || 'accept',
      // busy/accept/refuse
      callerDevId: _callManager.WebIM.conn.context.jid.clientResource,
      calleeDevId: calleeDevId,
      callId: currentCallId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora'
    },
    success: function success(id, serverMsgId) {
      if (result == 'accept') {
        dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.confirmCallee));
      }
    },
    fail: function fail(e) {
      console.warn("caller send confirmCallee fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);
};

var cancelCall = function cancelCall(to) {
  var getState = _redux["default"].getState;

  var id = _callManager.WebIM.conn.getUniqueId();

  var msg = new _callManager.WebIM.message('cmd', id);
  var callerDevId = getState().confr.callerDevId;
  var user = to || getState().confr.calleeIMName;
  var currentCallId = getState().confr.callId;

  if (!user) {
    console.warn('send cancelCall fail, to is undefined');
    return;
  }

  msg.set({
    to: user,
    action: 'rtcCall',
    ext: {
      action: 'cancelCall',
      callerDevId: callerDevId,
      callId: currentCallId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora'
    },
    success: function success(id, serverMsgId) {//dispatch(setCallStatus(CALLSTATUS.idle))
    },
    fail: function fail(e) {
      console.warn("caller send canlcel fail", msg);
    }
  });

  _callManager.WebIM.conn.send(msg.body);
};

exports.cancelCall = cancelCall;

var addListener = function addListener() {
  var getState = _redux["default"].getState,
      dispatch = _redux["default"].dispatch;

  _callManager.WebIM.conn.addEventHandler('message', {
    onTextMessage: function onTextMessage(message) {
      if (message.chatType !== 'singleChat') return;
      var state = getState();
      var conf = state.conf,
          callStatus = state.callStatus;
      var from = message.from,
          to = message.to;

      if (message.ext && message.ext.action === 'invite') {
        if (message.from == _callManager.WebIM.conn.context.jid.name) {
          return; // msg from other device
        }

        if (message.chatType == 'singleChat') {
          if (callStatus > _reducer.CALLSTATUS.idle) {
            // busy
            answerCall('busy', {
              currentCallId: message.ext.callId,
              callerDevId: message.ext.callerDevId,
              to: from
            });
          } else {
            message.ext.calleeIMName = message.to;
            message.ext.callerIMName = message.from;
            dispatch((0, _reducer.updateConfr)(message));
            dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
          }
        } else {
          var msgInfo = message.ext;

          if (callStatus > _reducer.CALLSTATUS.idle) {
            if (msgInfo.callId == conf.callId) {
              dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
            } else {
              answerCall('busy', {
                currentCallId: msgInfo.callId,
                callerDevId: msgInfo.callerDevId,
                to: from
              });
            }
          }

          msgInfo.calleeIMName = _callManager.WebIM.conn.context.jid.name;
          msgInfo.callerIMName = from;
          dispatch((0, _reducer.updateConfr)({
            from: from,
            to: to,
            ext: msgInfo
          }));
          dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
        }
      }
    },
    onCmdMessage: function onCmdMessage(msg) {
      if (msg.action === "rtcCall") {
        var msgInfo = msg.ext;
        var deviceId = '';
        var callerDevId = '';
        var callId = '';

        var callVideo = _redux["default"].getState();

        switch (msgInfo.action) {
          case "invite":
            return;

            if (msg.from == _callManager.WebIM.conn.context.jid.name) {
              return; // invite msg send by myself on another device
            }

            var state = getState();
            var conf = state.conf,
                callStatus = state.callStatus;
            var from = msg.from,
                to = msg.to;

            if (callStatus > _reducer.CALLSTATUS.idle) {
              if (msgInfo.callId == conf.callId) {
                dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
              } else {
                answerCall('busy', {
                  currentCallId: msgInfo.callId,
                  callerDevId: msgInfo.callerDevId,
                  to: from
                });
              }
            }

            msgInfo.calleeIMName = _callManager.WebIM.conn.context.jid.name;
            msgInfo.callerIMName = from;
            dispatch((0, _reducer.updateConfr)({
              from: from,
              to: to,
              ext: msgInfo
            }));
            dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.alerting));
            break;

          case "alert":
            deviceId = msgInfo.calleeDevId;
            callerDevId = msgInfo.callerDevId;
            callId = msgInfo.callId;
            confirmRing(msg.from, deviceId, callerDevId, callId);
            break;

          case "confirmRing":
            if (msgInfo.calleeDevId != _callManager.WebIM.conn.context.jid.clientResource) {
              return; // Multi-terminal case A message on the other end (calling a call from another device) caller
            }

            if (!msgInfo.status && callVideo.callStatus < _reducer.CALLSTATUS.receivedConfirmRing) {
              console.warn('The invitation has expired');
              dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));

              _callManager.callManager.hangup('invitation has expired'); // WebIM.rtc.timer && clearTimeout(WebIM.rtc.timer)


              return;
            }

            deviceId = msgInfo.calleeDevId;
            dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.receivedConfirmRing)); // answerCall(msg.from, deviceId)
            // WebIM.rtc.timer && clearTimeout(WebIM.rtc.timer)

            break;

          case "answerCall":
            _callManager.WebIM.rtc.timer && clearTimeout(_callManager.WebIM.rtc.timer);
            deviceId = msgInfo.calleeDevId;

            if (msgInfo.callerDevId != _callManager.WebIM.conn.context.jid.clientResource) {
              if (msg.from == _callManager.WebIM.conn.context.jid.name) {
                if (msgInfo.result === 'accept') {
                  _callManager.callManager.hangup('accepted on other devices');
                } else if (msgInfo.result === 'refuse') {
                  _callManager.callManager.hangup('refused on other devices');
                }

                dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
                _callManager.WebIM.rtc.timer && clearTimeout(_callManager.WebIM.rtc.timer);
                return console.warn('processed on other devices');
              }

              return; // 多端情况另一端的消息 （被叫 在其他设备处理）
            }

            if (msgInfo.result !== 'accept') {
              if (msgInfo.result === 'busy') {
                console.warn('target is busy');
              } else if (msgInfo.result === 'refuse') {
                console.error('the target has refused');
              }

              if (![2, 3].includes(callVideo.confr.type)) {
                // 1v1 hang up，multi don't hang up
                confirmCallee(msg.from, deviceId, msgInfo.result);

                _callManager.callManager.hangup(msgInfo.result);

                dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
              } else {
                confirmCallee(msg.from, deviceId, 'refuse');
              }
            } else {
              confirmCallee(msg.from, deviceId, msgInfo.result);
            }

            break;

          case "confirmCallee":
            if (msgInfo.calleeDevId != _callManager.WebIM.conn.context.jid.clientResource && callVideo.callStatus !== 7) {
              _callManager.callManager.hangup('processed on other devices');

              dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
              _callManager.WebIM.rtc.timer && clearTimeout(_callManager.WebIM.rtc.timer);
              return;
            }

            if (msg.ext.result != 'accept' && callVideo.callStatus !== 7) {
              // Hang up when busy Refuse is received during a call
              if (callVideo.callStatus !== 0) {
                _callManager.callManager.hangup(msg.ext.result);

                dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
              }

              _callManager.WebIM.rtc.timer && clearTimeout(_callManager.WebIM.rtc.timer);
              return;
            }

            dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.confirmCallee));
            break;

          case "cancelCall":
            if (msg.from == _callManager.WebIM.conn.context.jid.name) {
              return; // msg from other device
            }

            if (msg.from == callVideo.confr.callerIMName) {
              _callManager.callManager.hangup('cancel');

              dispatch((0, _reducer.setCallStatus)(_reducer.CALLSTATUS.idle));
            }

            break;

          default:
            console.warn("unexpected action " + msg.action);
            break;
        }
      }
    }
  });
};

exports.addListener = addListener;
manager.sendAlerting = sendAlerting;