import _regeneratorRuntime from "@babel/runtime/regenerator";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import AgoraRTC from 'agora-rtc-sdk-ng';
import WebIM from 'agora-chat';
import store from '../redux';
import { updateConfr, setCallStatus, CALLSTATUS, setCallDuration, changeWinSize, updateJoinedMembers, setUidToUserId, updateInvitedMembers } from '../redux/reducer';
import { sendTextMsg, addListener, cancelCall, sendAlerting } from './message';
import { formatTime } from './utils';
var client = AgoraRTC.createClient({
  mode: 'live',
  codec: 'h264'
});
client.setClientRole('host');

var Manager = /*#__PURE__*/function () {
  function Manager(params) {
    if (params) {
      this.init(params);
    }

    this.client = client;
    this.props = {};
    this.callId = '';
    WebIM.rtc = this.rtc = {
      client: client,
      localAudioTrack: null,
      localVideoTrack: null,
      timer: null
    };
  }

  var _proto = Manager.prototype;

  _proto.init = function init(appId, agoraUid, connection) {
    this.appId = appId;
    this.agoraUid = agoraUid;
    WebIM.conn = connection;
    addListener();
  };

  _proto.setCallKitProps = function setCallKitProps(props) {
    this.props = props;
  };

  _proto.changeState = function changeState(state) {
    this.props.onStateChange && this.props.onStateChange(state);
  };

  _proto.setToken = function setToken(accessToken) {
    this.accessToken = accessToken;
  };

  _proto.setUserIdMap = function setUserIdMap(idMap) {
    var getState = store.getState,
        dispatch = store.dispatch;
    dispatch(setUidToUserId(idMap));
  };

  _proto.answerCall = function answerCall(result, accessToken) {
    var getState = store.getState,
        dispatch = store.dispatch;
    var state = getState();
    var confr = state.confr;

    if (result) {
      this.accessToken = accessToken;
      sendAlerting(confr.callerIMName, confr.callerDevId, confr.callId);
    } else {
      var _dispatch = store.dispatch;

      _dispatch(setCallStatus(CALLSTATUS.idle));
    }
  };

  _proto.startCall = function startCall(options) {
    var getState = store.getState,
        dispatch = store.dispatch;
    var state = getState();
    var callId = options.callId,
        channel = options.channel,
        chatType = options.chatType,
        callType = options.callType,
        to = options.to,
        message = options.message,
        groupId = options.groupId,
        groupName = options.groupName,
        accessToken = options.accessToken;
    this.accessToken = accessToken;

    if (state.confr.callId && state.callStatus > 0) {
      channel = state.confr.channel;
      callId = state.confr.callId;
      callType = state.confr.type;
    }

    var confInfo = {
      action: 'invite',
      channelName: channel,
      type: callType,
      //0 1v1 audio，1 1v1 video，2 multi video 3 multi audio
      callerDevId: WebIM.conn.context.jid.clientResource,
      callId: callId,
      ts: Date.now(),
      msgType: 'rtcCallWithAgora',
      callerIMName: WebIM.conn.context.jid.name,
      // for ios push
      chatType: callType,
      em_push_ext: {
        type: 'call',
        custom: {
          callId: callId
        }
      },
      em_apns_ext: {
        em_push_type: 'voip'
      }
    };
    var msgExt = {
      channelName: channel,
      token: null,
      type: callType,
      callerDevId: WebIM.conn.context.jid.clientResource,
      callId: callId,
      calleeIMName: to,
      callerIMName: WebIM.conn.context.jid.name
    };
    this.callId = callId;

    if (callType === 2 || callType === 3) {
      confInfo.ext = {
        groupId: groupId,
        groupName: groupName
      };
      msgExt.ext = {
        groupId: groupId,
        groupName: groupName
      };
      var invitedMembers = state.invitedMembers;

      if (!invitedMembers.includes(to)) {
        dispatch(updateInvitedMembers([].concat(invitedMembers, [to])));
      }
    }

    if (chatType === 'groupChat') {// confInfo.ext = {
      // 	groupId: groupId,
      // 	groupName: groupName
      // }
      // msgExt.ext = {
      // 	groupId: groupId,
      // 	groupName: groupName
      // }
      // let invitedMembers = state.invitedMembers
      // dispatch(updateInvitedMembers([...invitedMembers, to]))
      // // sendCMDMsg(chatType, to, message, confInfo)
      // sendTextMsg(chatType, to, message, confInfo)
    } else {
      sendTextMsg(chatType, to, message, confInfo);
    }

    dispatch(updateConfr({
      ext: msgExt,
      to: to,
      from: WebIM.conn.context.jid.name
    }));

    if (state.callStatus < CALLSTATUS.inviting) {
      dispatch(setCallStatus(CALLSTATUS.inviting));
    }
  };

  _proto.join = /*#__PURE__*/function () {
    var _join = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var getState, dispatch, state, confr, username, uid, localAudioTrack, config, displayedName, localVideoTrack, videoElm;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              getState = store.getState, dispatch = store.dispatch;
              state = getState();

              if (!(state.callStatus === CALLSTATUS.confirmCallee)) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return");

            case 4:
              confr = state.confr;
              username = WebIM.conn.context.userId;
              _context.next = 8;
              return client.join(this.appId, confr.channel, this.accessToken, Number(this.agoraUid));

            case 8:
              uid = _context.sent;
              _context.next = 11;
              return AgoraRTC.createMicrophoneAudioTrack();

            case 11:
              localAudioTrack = _context.sent;
              this.rtc.localAudioTrack = localAudioTrack;
              config = [localAudioTrack];
              displayedName = username;

              if (state.uid2userId[uid]) {
                displayedName = state.uid2userId[uid];
              } else if (state.uid2userId[username]) {
                displayedName = state.uid2userId[username];
              }

              if (!(confr.type === 0 || confr.type === 3)) {
                _context.next = 22;
                break;
              }

              _context.next = 19;
              return client.publish(config);

            case 19:
              dispatch(updateJoinedMembers({
                videoElm: null,
                name: displayedName,
                type: 'audio',
                value: uid,
                action: 'add',
                audio: true,
                video: false,
                isSelf: true
              }));
              _context.next = 32;
              break;

            case 22:
              _context.next = 24;
              return AgoraRTC.createCameraVideoTrack();

            case 24:
              localVideoTrack = _context.sent;
              config.push(localVideoTrack);
              this.rtc.localVideoTrack = localVideoTrack;
              _context.next = 29;
              return client.publish(config);

            case 29:
              videoElm = confr.type === 2 ? 'video' + uid : 'local-player';
              dispatch(updateJoinedMembers({
                videoElm: videoElm,
                name: displayedName,
                type: 'video',
                value: uid,
                action: 'add',
                audio: true,
                video: true,
                isSelf: true
              }));
              localVideoTrack.play(videoElm);

            case 32:
              this.startTime();

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function join() {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.startTime = function startTime() {
    var dispatch = store.dispatch;
    var hour = 0,
        minute = 0,
        second = 0;
    this.rtc.intervalTimer && clearInterval(WebIM.rtc.intervalTimer);
    var timerId = setInterval(function () {
      second += 1;

      if (second === 60) {
        second = 0;
        minute += 1;

        if (minute === 60) {
          minute = 0;
          hour += 1;

          if (hour == 24) {
            hour = 0;
          }
        }
      }

      var time = formatTime(hour, minute, second);
      dispatch(setCallDuration(time));
    }, 1000);
    this.rtc.intervalTimer = timerId;
  };

  _proto.hangup = /*#__PURE__*/function () {
    var _hangup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(reson, isCancel) {
      var getState, dispatch, state, confr;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this.rtc.localAudioTrack && this.rtc.localAudioTrack.close();
              this.rtc.localVideoTrack && this.rtc.localVideoTrack.close();
              this.rtc.intervalTimer && clearInterval(this.rtc.intervalTimer);
              getState = store.getState, dispatch = store.dispatch;
              state = getState();
              confr = state.confr;

              if (isCancel && confr.callerIMName == WebIM.conn.context.jid.name) {
                if (confr.type == 2 || confr.type == 3) {
                  state.invitedMembers.forEach(function (member) {
                    cancelCall(member);
                  });
                } else {
                  cancelCall();
                }
              }

              this.props.onStateChange && this.props.onStateChange({
                type: 'hangup',
                reson: reson,
                callInfo: _extends({}, state.confr, {
                  duration: state.callDuration,
                  groupId: state.groupId,
                  groupName: state.groupName
                })
              });
              this.callId = '';
              _context2.t0 = this.rtc.client;

              if (!_context2.t0) {
                _context2.next = 13;
                break;
              }

              _context2.next = 13;
              return this.rtc.client.leave();

            case 13:
              dispatch(setCallStatus(CALLSTATUS.idle));
              dispatch(setCallDuration('00:00'));
              dispatch(changeWinSize('normal'));
              dispatch(updateJoinedMembers([]));
              dispatch(updateInvitedMembers([]));
              dispatch(updateConfr({
                to: '',
                ext: {}
              }));

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function hangup(_x, _x2) {
      return _hangup.apply(this, arguments);
    }

    return hangup;
  }();

  return Manager;
}();

export var callManager = new Manager();
export { client, WebIM };