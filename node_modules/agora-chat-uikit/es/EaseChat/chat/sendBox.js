import React, { memo, useCallback, useEffect, useRef, useState, useContext } from "react";
import { makeStyles } from "@material-ui/styles";
import Typography from "@material-ui/core/Typography";
import { Box, IconButton, MenuItem, TextareaAutosize, Menu } from "@material-ui/core";
import EmojiCom from "./toolbars/emoji";
import { useDispatch, useSelector } from "react-redux";
import MessageActions from "../../redux/message";
import PropTypes from "prop-types";
import i18next from "i18next";
import WebIM from "../../utils/WebIM";
import { EaseChatContext } from "./index";
import Recorder from "./messages/recorder";
import icon_emoji from "../../common/icons/emoji@2x.png";
import icon_yuyin from "../../common/icons/voice@2x.png";
import attachment from "../../common/icons/attachment@2x.png";
import { message } from '../common/alert';
import { getLocalStorageData } from '../../utils/index';
import { emoji } from "../../common/emoji";
var useStyles = makeStyles(function (theme) {
  return {
    root: {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      background: "#fff",
      borderRadius: "2px",
      position: "absolute",
      bottom: '-25px',
      padding: "10px 0"
    },
    emitter: {
      display: "flex",
      alignItems: "flex-end",
      padding: "0 16px"
    },
    input: {
      outline: "none",
      flex: 1,
      lineHeight: "17px",
      fontSize: "14px",
      border: "none",
      color: "#010101",
      resize: "none",
      backgroundColor: "#efefef",
      borderRadius: "18px",
      padding: "5px",
      fontFamily: 'Roboto',
      width: '96%'
    },
    senderBar: {
      height: "12px",
      width: "12px",
      cursor: "pointer"
    },
    hide: {
      display: "none"
    },
    iconStyle: {
      width: "30px",
      height: "30px"
    },
    menuItemIconBox: {
      marginRight: "5px",
      display: "flex"
    },
    textareaBox: {
      backgroundColor: "#efefef",
      width: '100%',
      borderRadius: "18px",
      minHeight: '36px',
      padding: '10px 0 0 8px',
      outline: '0 none',
      textAlign: 'left',
      maxHeight: '70px',
      overflow: 'auto',
      position: 'relative',
      '&::before': {
        content: '"Say Something"',
        position: 'absolute',
        top: '10px',
        left: '10px',
        color: '#999'
      }
    },
    iconbtnStyle: {
      padding: '2px',
      margin: '6px 0'
    },
    emojiInsert: {
      marginLeft: '5px',
      verticalAlign: 'middle'
    },
    textareaSubBox: {
      backgroundColor: "#efefef",
      width: '100%',
      borderRadius: "18px",
      minHeight: '36px',
      padding: '10px 0 0 8px',
      outline: '0 none',
      textAlign: 'left',
      maxHeight: '70px',
      overflow: 'auto'
    }
  };
});

function SendBox(props) {
  var easeChatProps = useContext(EaseChatContext);
  var easeInputMenu = easeChatProps.easeInputMenu,
      menuList = easeChatProps.menuList,
      handleMenuItem = easeChatProps.handleMenuItem,
      onOpenThreadPanel = easeChatProps.onOpenThreadPanel;
  var dispatch = useDispatch();
  var classes = useStyles();
  var globalProps = useSelector(function (state) {
    return state.global.globalProps;
  });
  var chatType = globalProps.chatType,
      to = globalProps.to;
  var emojiRef = useRef(null);
  var fileEl = useRef(null);
  var videoEl = useRef(null);

  var _useState = useState(null),
      emojiVisible = _useState[0],
      setEmojiVisible = _useState[1];

  var _useState2 = useState(""),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var inputRef = useRef(null);
  var inputValueRef = useRef(null);
  var imageEl = useRef(null);

  var _useState3 = useState(null),
      sessionEl = _useState3[0],
      setSessionEl = _useState3[1];

  var _useState4 = useState(false),
      showRecorder = _useState4[0],
      setShowRecorder = _useState4[1];

  var _useState5 = useState(true),
      typingTime = _useState5[0],
      setTypingTime = _useState5[1];

  var _useState6 = useState(true),
      inputHaveValue = _useState6[0],
      setInputHaveValue = _useState6[1];

  inputValueRef.current = inputValue;

  var handleClickEmoji = function handleClickEmoji(e) {
    setEmojiVisible(e.currentTarget);
  };

  var handleEmojiClose = function handleEmojiClose() {
    setEmojiVisible(null);
  };

  var insertCustomHtml = function insertCustomHtml(t, e) {
    var i = inputRef.current;
    i.innerText.length;

    if ("getSelection" in window) {
      var s = window.getSelection();

      if (s && 1 === s.rangeCount) {
        i.focus();
        var n = s.getRangeAt(0),
            a = new Image();
        a.src = t, a.setAttribute("data-key", e), a.setAttribute("width", 20), a.setAttribute("height", 20), a.draggable = !1, a.className = classes.emojiInsert, a.setAttribute("title", e.replace("[", "").replace("]", "")), n.deleteContents(), n.insertNode(a), n.collapse(!1), s.removeAllRanges(), s.addRange(n);
      }
    } else if ("selection" in document) {
      i.focus(), (n = document.selection.createRange()).pasteHTML('<img class="emoj-insert" draggable="false" data-key="' + e + '" title="' + e.replace("[", "").replace("]", "") + '" src="' + t + '">'), i.focus();
    }

    var str = converToMessage(i.innerHTML).trim();
    setInputValue(str);
  };

  var handleEmojiSelected = function handleEmojiSelected(res) {
    if (!res) return;
    setEmojiVisible(null);
    setInputValue(function (value) {
      return value + res;
    });

    var src = require("../../common/reactions/" + emoji.map[res])["default"];

    insertCustomHtml(src, res);
    setInputHaveValue(false);
    setTimeout(function () {
      var el = inputRef.current;
      el.focus();
      el.selectionStart = inputValueRef.current.length;
      el.selectionEnd = inputValueRef.current.length;
    }, 0);
  };

  var openTyping = function openTyping() {
    dispatch(MessageActions.sendCmdMessage(to, chatType, 'TypingBegin', props.isChatThread));
  };

  function converToMessage(e) {
    var t = function () {
      var t = [],
          r = document.createElement("div");
      r.innerHTML = e.replace(/\\/g, "###h###");

      for (var n = r.querySelectorAll("img"), a = r.querySelectorAll("div"), i = n.length, o = a.length; i--;) {
        var s = document.createTextNode(n[i].getAttribute("data-key"));
        n[i].parentNode.insertBefore(s, n[i]);
        n[i].parentNode.removeChild(n[i]);
      }

      for (; o--;) {
        t.push(a[o].innerHTML), a[o].parentNode.removeChild(a[o]);
      }

      var c = (t = t.reverse()).length ? "\n" + t.join("\n") : t.join("\n");
      return (r.innerText + c).replace(/###h###/g, "&#92;").replace(/<br>/g, "\n").replace(/&amp;/g, "&");
    }();

    new RegExp("(^[\\s\\n\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\n\\s\\t]+$)", "g");
    return t.replace(/&nbsp;/g, " ").trim();
  }

  var handleInputChange = function handleInputChange(e) {
    var html = e.target.innerHTML;

    if (html.length) {
      setInputHaveValue(false);
    } else {
      setInputHaveValue(true);
    }

    var str = converToMessage(html).trim();
    setInputValue(str);

    if (getLocalStorageData().typingSwitch && typingTime) {
      setTypingTime(false);
      openTyping();
      setTimeout(function () {
        setTypingTime(true);
      }, 10000);
    }
  };

  var isCreatingThread = useSelector(function (state) {
    var _state$thread;

    return (_state$thread = state.thread) === null || _state$thread === void 0 ? void 0 : _state$thread.isCreatingThread;
  });
  var currentThreadInfo = useSelector(function (state) {
    var _state$thread2;

    return (_state$thread2 = state.thread) === null || _state$thread2 === void 0 ? void 0 : _state$thread2.currentThreadInfo;
  });
  var threadOriginalMsg = useSelector(function (state) {
    var _state$thread3;

    return (_state$thread3 = state.thread) === null || _state$thread3 === void 0 ? void 0 : _state$thread3.threadOriginalMsg;
  });
  var threadPanelStates = useSelector(function (state) {
    var _state$thread4;

    return (_state$thread4 = state.thread) === null || _state$thread4 === void 0 ? void 0 : _state$thread4.threadPanelStates;
  });
  useEffect(function () {
    if (threadPanelStates) {
      setInputValue('');
    }
  }, [isCreatingThread, currentThreadInfo === null || currentThreadInfo === void 0 ? void 0 : currentThreadInfo.id, threadOriginalMsg === null || threadOriginalMsg === void 0 ? void 0 : threadOriginalMsg.id, threadPanelStates]);

  var createChatThread = function createChatThread() {
    return new Promise(function (resolve, reject) {
      if (isCreatingThread && props.isChatThread) {
        if (!props.threadName) {
          message.warn(i18next.t('ThreadName can not empty'));
          imageEl.current.value = null;
          fileEl.current.value = null;
          videoEl.current.value = null;
          return;
        }

        var options = {
          name: props.threadName.replace(/(^\s*)|(\s*$)/g, ""),
          messageId: threadOriginalMsg.id,
          parentId: threadOriginalMsg.to
        };
        WebIM.conn.createChatThread(options).then(function (res) {
          var _res$data;

          var threadId = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.chatThreadId;
          onOpenThreadPanel && onOpenThreadPanel({
            id: threadId
          });
          resolve(threadId);
        });
      } else if (props.isChatThread) {
        resolve(currentThreadInfo.id);
      } else {
        resolve(to);
      }
    });
  };

  var sendMessage = useCallback(function () {
    if (!inputValue) return;
    createChatThread().then(function (to) {
      dispatch(MessageActions.sendTxtMessage(to, chatType, {
        msg: inputValue
      }, props.isChatThread));
      inputRef.current.innerHTML = '';
      setInputHaveValue(true);
      setInputValue("");
      inputRef.current.focus();
    });
  }, [inputValue, to, chatType, dispatch, currentThreadInfo, props]);
  var onKeyDownEvent = useCallback(function (e) {
    if (e.keyCode === 13 && e.shiftKey) {
      e.preventDefault();
      inputRef.current.value += "\n";
    } else if (e.keyCode === 13) {
      e.preventDefault();
      sendMessage();
    }
  }, [sendMessage]);
  useEffect(function () {
    inputRef.current.addEventListener("keydown", onKeyDownEvent);
    return function cleanup() {
      var _inputRef$current;

      var _inputRef = inputRef;
      _inputRef && (_inputRef === null || _inputRef === void 0 ? void 0 : (_inputRef$current = _inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.removeEventListener("keydown", onKeyDownEvent));
    };
  }, [onKeyDownEvent]);

  var handlefocus = function handlefocus(v) {
    var value = v.value;

    switch (value) {
      case 'img':
        imageEl.current.focus();
        imageEl.current.click();
        break;

      case 'file':
        fileEl.current.focus();
        fileEl.current.click();
        break;

      case 'video':
        videoEl.current.focus();
        videoEl.current.click();

      default:
        break;
    }
  };

  var handleFileChange = function handleFileChange(e) {
    var file = WebIM.utils.getFileUrl(e.target);

    if (!file.filename) {
      return false;
    }

    createChatThread().then(function (to) {
      dispatch(MessageActions.sendFileMessage(to, chatType, file, fileEl, props.isChatThread));
    });
  };

  var handleVideoChange = function handleVideoChange(e) {
    var file = WebIM.utils.getFileUrl(e.target);

    if (!file.filename) {
      return false;
    }

    createChatThread().then(function (to) {
      dispatch(MessageActions.sendVideoMessage(to, chatType, file, videoEl, props.isChatThread));
    });
  };

  var handleImageChange = function handleImageChange(e) {
    var file = WebIM.utils.getFileUrl(e.target);

    if (!file.filename) {
      return false;
    }

    createChatThread().then(function (to) {
      dispatch(MessageActions.sendImgMessage(to, chatType, file, imageEl, props.isChatThread));
    });
  };

  var handleClickMenu = function handleClickMenu(e) {
    setSessionEl(e.currentTarget);
  };

  var onClickMenuItem = function onClickMenuItem(v) {
    return function (e) {
      handleMenuItem && handleMenuItem(v, e);
      handlefocus(v);
      setSessionEl(null);
    };
  };
  /*------------ ui-menu ----------*/


  var renderMenu = function renderMenu() {
    return /*#__PURE__*/React.createElement(Menu, {
      id: "simple-menu",
      anchorEl: sessionEl,
      keepMounted: true,
      open: Boolean(sessionEl),
      onClose: function onClose() {
        return setSessionEl(null);
      },
      anchorOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "bottom",
        horizontal: "right"
      }
    }, menuList && menuList.map(function (option, index) {
      return /*#__PURE__*/React.createElement(MenuItem, {
        onClick: onClickMenuItem(option),
        key: index
      }, /*#__PURE__*/React.createElement(Box, {
        className: classes.menuItemIconBox
      }), /*#__PURE__*/React.createElement(Typography, {
        variant: "inherit",
        noWrap: true
      }, i18next.t(option.name)), option.value === "img" && /*#__PURE__*/React.createElement("input", {
        type: "file",
        accept: "image/gif,image/jpeg,image/jpg,image/png,image/svg",
        ref: imageEl,
        onChange: handleImageChange,
        className: classes.hide
      }), option.value === "file" && /*#__PURE__*/React.createElement("input", {
        ref: fileEl,
        onChange: handleFileChange,
        type: "file",
        className: classes.hide
      }), option.value === "video" && /*#__PURE__*/React.createElement("input", {
        ref: videoEl,
        onChange: handleVideoChange,
        type: "file",
        className: classes.hide
      }));
    }));
  };

  var renderRecorder = function renderRecorder() {
    return /*#__PURE__*/React.createElement(React.Fragment, null, window.location.protocol === "https:" && /*#__PURE__*/React.createElement(IconButton, {
      className: classes.iconbtnStyle,
      onClick: function onClick() {
        setShowRecorder(true);
      }
    }, /*#__PURE__*/React.createElement("img", {
      alt: "",
      className: classes.iconStyle,
      src: icon_yuyin
    })), /*#__PURE__*/React.createElement(Recorder, {
      open: showRecorder,
      onClose: function onClose() {
        setShowRecorder(false);
      },
      isChatThread: props.isChatThread,
      threadName: props.threadName
    }));
  };

  var renderTextarea = function renderTextarea() {
    return (
      /*#__PURE__*/
      // <div className={classes.textareaBox}>
      //   <TextareaAutosize
      //     placeholder="Say Something"
      //     className={classes.input}
      //     minRows={1}
      //     maxRows={3}
      //     value={inputValue}
      //     onChange={handleInputChange}
      //     ref={inputRef}
      //   ></TextareaAutosize>
      // </div>
      React.createElement("div", {
        contentEditable: "true",
        className: "" + (inputHaveValue ? classes.textareaBox : classes.textareaSubBox),
        ref: inputRef,
        onInput: handleInputChange
      })
    );
  };

  var renderEmoji = function renderEmoji() {
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
      ref: emojiRef,
      className: classes.iconbtnStyle,
      onClick: handleClickEmoji
    }, /*#__PURE__*/React.createElement("img", {
      alt: "",
      className: classes.iconStyle,
      src: icon_emoji
    })), /*#__PURE__*/React.createElement(EmojiCom, {
      anchorEl: emojiVisible,
      onSelected: handleEmojiSelected,
      onClose: handleEmojiClose
    }));
  };

  var renderMoreFeatures = function renderMoreFeatures() {
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
      className: classes.iconbtnStyle,
      onClick: handleClickMenu
    }, /*#__PURE__*/React.createElement("img", {
      alt: "",
      className: classes.iconStyle,
      src: attachment
    })), renderMenu());
  };

  var renderConditionModule = function renderConditionModule() {
    switch (easeInputMenu) {
      case "all":
        return /*#__PURE__*/React.createElement(React.Fragment, null, renderRecorder(), renderTextarea(), renderEmoji(), renderMoreFeatures());

      case "noAudio":
        return /*#__PURE__*/React.createElement(React.Fragment, null, renderTextarea(), renderEmoji(), renderMoreFeatures());

      case "noEmoji":
        return /*#__PURE__*/React.createElement(React.Fragment, null, renderRecorder(), renderTextarea(), renderMoreFeatures());

      case "noAudioAndEmoji":
        return /*#__PURE__*/React.createElement(React.Fragment, null, renderTextarea(), renderMoreFeatures());

      case "onlyText":
        return /*#__PURE__*/React.createElement(React.Fragment, null, renderTextarea());

      default:
        break;
    }
  };

  return /*#__PURE__*/React.createElement(Box, {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Box, {
    className: classes.emitter
  }, renderConditionModule()));
}

export default memo(SendBox);