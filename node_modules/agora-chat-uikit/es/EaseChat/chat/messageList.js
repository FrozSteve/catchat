import React, { memo, useRef, useEffect, useState, useCallback } from "react";
import ReactDOM from "react-dom";
import { makeStyles } from "@material-ui/styles";
import "./index.css";
import { useDispatch, useSelector } from "react-redux";
import MessageActions from "../../redux/message";
import RetractedMessage from "./messages/retractedMessage";
import FileMessage from "./messages/fileMessage";
import ImgMessage from "./messages/imageMessage";
import AudioOrVideoMessage from "./messages/audioOrVideoMessage";
import TextMessage from "./messages/textMessage";
import NoticeMessage from './messages/noticeMessage';
import CustomMessage from './messages/customMessage';
import ThreadActions from "../../redux/thread";
import i18next from "i18next";
import ThreadNotify from "./messages/threadNotify";
import Notify from './messages/notify';
import loadMore from '../../common/icons/loadmore@2x.png';
var useStyles = makeStyles(function (theme) {
  return {
    root: {
      width: "100%",
      flex: 1,
      display: "flex",
      position: "relative",
      bottom: "0",
      top: "0",
      overflow: "hidden"
    },
    loadMore: {
      width: '16px',
      height: '16px',
      animation: "rotate 800ms infinite"
    },
    "@keyframes rotate": {
      "0%": {
        transform: "rotate(0deg)"
      },
      "100%": {
        transform: "rotate(360deg)"
      }
    }
  };
});
var PAGE_NUM = 20;

function MessageList(_ref) {
  var messageList = _ref.messageList,
      showByselfAvatar = _ref.showByselfAvatar;
  var classes = useStyles();
  var dispatch = useDispatch();
  var globalProps = useSelector(function (state) {
    return state.global.globalProps;
  });
  var showThread = useSelector(function (state) {
    return state.thread.showThread;
  });
  var to = globalProps.to,
      chatType = globalProps.chatType;
  console.log("** Render MessageList **", messageList);
  var scrollEl = useRef(null);

  var _useState = useState(false),
      isPullingDown = _useState[0],
      setIsPullingDown = _useState[1];

  var _useState2 = useState(false),
      isLoaded = _useState2[0],
      setIsLoaded = _useState2[1];

  var _not_scroll_bottom = false;

  var _useState3 = useState(0),
      boxScrollHeight = _useState3[0],
      setBoxScrollHeight = _useState3[1];

  useEffect(function () {
    // if (!_not_scroll_bottom) {
    //   setTimeout(() => {
    //     const dom = scrollEl.current;
    //     if (!ReactDOM.findDOMNode(dom)) return;
    //     dom.scrollTop = dom.scrollHeight;
    //   }, 0);
    // }
    var tempArr = [];
    messageList.forEach(function (item) {
      if (item.body.type === 'img' || item.body.type === 'video') {
        tempArr.push(item.body);
      }
    });
    var time = tempArr.length ? tempArr.length * 1000 : 510;
    var TimerId = setInterval(function () {
      if (document.getElementById('pulldownList')) {
        setBoxScrollHeight(document.getElementById('pulldownList').scrollHeight);
      }
    }, 500);
    var TimeId = setTimeout(function () {
      clearTimeout(TimeId);
      clearInterval(TimerId);
    }, time);
  }, [messageList.length]);
  useEffect(function () {
    document.getElementById('pulldownList').scrollIntoView({
      behavior: 'smooth',
      block: 'end'
    });
  }, [boxScrollHeight]);
  var handleRecallMsg = useCallback(function (message) {
    console.log("handleRecallMsg", message);
    var to = message.to,
        chatType = message.chatType;
    dispatch(MessageActions.recallMessage(to, chatType, message));
  }, [dispatch]);

  var handleScroll = function handleScroll(e) {
    if (e.target.scrollTop === 0 && !isLoaded) {
      setTimeout(function () {
        var offset = messageList.length;
        dispatch(MessageActions.fetchMessage(to, chatType, offset, function (res) {
          setIsPullingDown(false);

          if (res < PAGE_NUM) {
            setIsLoaded(true);
          }
        }));
      }, 500);
      setIsPullingDown(true);
    }
  };

  var createThread = function createThread(message) {
    //update currentThreadInfo
    dispatch(ThreadActions.setThreadOriginalMsg(message));
    dispatch(ThreadActions.setCurrentThreadInfo({})); //updated the historyStatus of Newly created chatThread

    dispatch(MessageActions.setThreadHasHistory(false)); //change the status of threadPanel

    dispatch(ThreadActions.updateThreadStates(true)); //change the status of creatingThread

    dispatch(ThreadActions.setIsCreatingThread(true));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement("div", {
    className: "pulldown-wrapper",
    onScroll: handleScroll
  }, /*#__PURE__*/React.createElement("div", {
    className: "pulldown-tips"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: isLoaded ? "block" : "none"
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: "12px"
    }
  }, i18next.t("no more messages"))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: isPullingDown ? "block" : "none"
    }
  }, /*#__PURE__*/React.createElement("span", null, /*#__PURE__*/React.createElement("img", {
    className: classes.loadMore,
    src: loadMore,
    alt: "Loading..."
  })))), /*#__PURE__*/React.createElement("ul", {
    ref: scrollEl,
    className: "pulldown-list",
    id: "pulldownList"
  }, messageList.length ? messageList.map(function (msg, index) {
    if (msg.body.type === "txt") {
      return /*#__PURE__*/React.createElement(TextMessage, {
        message: msg,
        key: msg.id + index,
        onRecallMessage: handleRecallMsg,
        onCreateThread: createThread,
        showByselfAvatar: showByselfAvatar,
        showThread: showThread
      });
    } else if (msg.body.type === "file") {
      return /*#__PURE__*/React.createElement(FileMessage, {
        message: msg,
        key: msg.id + index,
        onRecallMessage: handleRecallMsg,
        onCreateThread: createThread,
        showByselfAvatar: showByselfAvatar,
        showThread: showThread
      });
    } else if (msg.body.type === "img") {
      return /*#__PURE__*/React.createElement(ImgMessage, {
        message: msg,
        key: msg.id + index,
        onRecallMessage: handleRecallMsg,
        onCreateThread: createThread,
        showByselfAvatar: showByselfAvatar,
        showThread: showThread
      });
    } else if (msg.body.type === "audio" || msg.body.type === "video") {
      return /*#__PURE__*/React.createElement(AudioOrVideoMessage, {
        message: msg,
        key: msg.id + index,
        showByselfAvatar: showByselfAvatar
      });
    } else if (msg.body.type === "recall") {
      return /*#__PURE__*/React.createElement(RetractedMessage, {
        message: msg,
        key: msg.id + index
      });
    } else if (msg.body.type === "notice") {
      return /*#__PURE__*/React.createElement(NoticeMessage, {
        message: msg,
        key: msg.id + index
      });
    } else if (msg.body.type === 'custom') {
      return /*#__PURE__*/React.createElement(CustomMessage, {
        message: msg,
        key: msg.id + index
      });
    } else if (msg.body.type === "threadNotify") {
      return /*#__PURE__*/React.createElement(ThreadNotify, {
        message: msg,
        key: msg.id + index
      });
    } else if (msg.body.type === "notify") {
      return /*#__PURE__*/React.createElement(Notify, {
        message: msg,
        key: msg.id + index
      });
    } else {
      return null;
    }
  }) : null)));
}

export default memo(MessageList);