import _regeneratorRuntime from "@babel/runtime/regenerator";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import React, { useEffect, memo, createContext, useState, useContext } from "react";
import PropTypes from "prop-types";
import { makeStyles } from "@material-ui/styles";
import MessageList from "./messageList";
import MessageBar from "./messageBar/index";
import { useSelector } from "../../EaseApp/index";
import { Provider } from "react-redux";
import SendBox from "./sendBox";
import WebIM, { initIMSDK } from "../../utils/WebIM";
import store from "../../redux/index";
import createlistener from "../../utils/WebIMListen";
import _ from "lodash";
import "../../i18n";
import "../../common/iconfont.css";
import noMessage from "../../common/images/nomessage.jpg";
import contactAvatar from "../../common/images/avatar1.jpg";
import groupAvatar from "../../common/images/groupAvatar.png";
import i18next from "i18next";
import CallKit from 'chat-callkit';
import MessageActions from "../../redux/message";
import ThreadPanel from "../thread/threadPanel";
export var EaseChatContext = createContext();
import { message } from '../common/alert';
var useStyles = makeStyles(function (theme) {
  return {
    root: {
      width: "100%",
      height: "calc(100% - 20px)",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "space-between",
      position: "relative"
    }
  };
});

var Chat = function Chat(props) {
  var agoraUid = props.agoraUid,
      appId = props.appId,
      getIdMap = props.getIdMap;

  var _useState = useState({}),
      confrData = _useState[0],
      setConfr = _useState[1];

  useEffect(function () {
    if (props.appkey && props.username && (props.agoraToken || props.password)) {
      initIMSDK(props.appkey);
      createlistener(props);

      if (WebIM.conn.logOut) {
        login();
      }
    }
  }, []);
  useEffect(function () {
    var appId = '15cb0d28b87b425ea613fc46f7c9f974';
    console.log('初始化 callkit', agoraUid);
    CallKit.init(appId, agoraUid || '', WebIM.conn);
  }, [agoraUid]);

  var login = function login() {
    var noLogin = WebIM.conn.logOut;

    if (props.agoraToken) {
      noLogin && WebIM.conn.open({
        user: props.username,
        agoraToken: props.agoraToken,
        pwd: props.password,
        appKey: WebIM.config.appkey
      });
    } else if (props.password) {
      noLogin && WebIM.conn.open({
        user: props.username,
        pwd: props.password,
        appKey: WebIM.config.appkey
      });
    }
  };

  var classes = useStyles();
  var messageList = useSelector(function (state) {
    var to = state.global.globalProps.to;
    var chatType = state.global.globalProps.chatType;
    return _.get(state, ["message", chatType, to], []);
  }) || [];

  var _useState2 = useState(false),
      showInviteModal = _useState2[0],
      setShowInvite = _useState2[1];

  var showInvite = function showInvite(confr) {
    console.log('点击添加人', confr);
    setConfr(confr);
    setShowInvite(!showInviteModal);
  };

  var closeInviteModal = function closeInviteModal() {
    setShowInvite(false);
  };

  var handleCallStateChange = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(info) {
      var chatType, targetId, id, cusMessage, idMap;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log('info ----', info);
              _context.t0 = info.type;
              _context.next = _context.t0 === 'hangup' ? 4 : _context.t0 === 'refuse' ? 4 : _context.t0 === 'user-published' ? 13 : 21;
              break;

            case 4:
              setConfr({});
              chatType = 'singleChat';
              targetId = '';

              if (info.callInfo.groupId) {
                targetId = info.callInfo.groupId;
                chatType = 'groupChat';
              } else if (info.callInfo.callerIMName == WebIM.conn.context.userId) {
                targetId = info.callInfo.calleeIMName;
              } else {
                targetId = info.callInfo.callerIMName;
              }

              id = WebIM.conn.getUniqueId();
              cusMessage = {
                id: id,
                status: 'sent',
                body: {
                  type: 'custom',
                  info: info.callInfo
                },
                from: WebIM.conn.context.userId,
                to: targetId,
                chatType: chatType
              };
              store.dispatch(MessageActions.addMessage(cusMessage));

              if (info.type == 'hangup') {
                if (info.reson == 'timeout') {
                  message.error('No response.');
                } else if (info.reson == 'refuse') {
                  message.error('Request declined.');
                } else if (info.reson == 'cancel') {
                  message.error('The call has been canceled.');
                } else if (info.reson == 'accepted on other devices') {
                  message.error('Other devices connected.');
                } else if (info.reson == 'refused on other devices') {
                  message.error('Other devices declined.');
                } else if (info.reson == 'busy') {
                  message.error('The line is busy.');
                } else {
                  message.error(info.reson || 'normal hangup');
                }
              }

              return _context.abrupt("break", 22);

            case 13:
              if (info.confr) {
                _context.next = 15;
                break;
              }

              return _context.abrupt("return");

            case 15:
              _context.next = 17;
              return getIdMap({
                userId: WebIM.conn.context.userId,
                channel: info.confr.channel
              });

            case 17:
              idMap = _context.sent;
              console.log('idMap', idMap);

              if (Object.keys(idMap).length > 0) {
                CallKit.setUserIdMap(idMap);
              }

              return _context.abrupt("break", 22);

            case 21:
              return _context.abrupt("break", 22);

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function handleCallStateChange(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var handleInvite = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data) {
      var _yield$props$getRTCTo, agoraUid, accessToken;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // props.onRTCInvite && props.onRTCInvite(data)
              console.log('收到邀请', data);
              _context2.next = 3;
              return props.getRTCToken({
                channel: data.channel,
                username: WebIM.conn.context.userId
              });

            case 3:
              _yield$props$getRTCTo = _context2.sent;
              agoraUid = _yield$props$getRTCTo.agoraUid;
              accessToken = _yield$props$getRTCTo.accessToken;
              CallKit.answerCall(true, accessToken);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function handleInvite(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  var to = useSelector(function (state) {
    return state.global.globalProps.to;
  });
  var showRTCCall = props.showRTCCall;
  return to ? /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(EaseChatContext.Provider, {
    value: props
  }, /*#__PURE__*/React.createElement(MessageBar, {
    showinvite: showInviteModal,
    onInviteClose: closeInviteModal,
    confrData: confrData
  }), /*#__PURE__*/React.createElement(MessageList, {
    messageList: messageList,
    showByselfAvatar: props.showByselfAvatar
  }), /*#__PURE__*/React.createElement(SendBox, null), !showRTCCall ? /*#__PURE__*/React.createElement(CallKit, {
    onAddPerson: showInvite,
    onStateChange: handleCallStateChange,
    onInvite: handleInvite,
    contactAvatar: contactAvatar,
    groupAvatar: groupAvatar,
    ringingSource: props.ringingSource
  }) : null)) : /*#__PURE__*/React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }
  }, /*#__PURE__*/React.createElement("img", {
    src: noMessage,
    alt: "",
    style: {
      height: "200px",
      width: "200px"
    }
  }), /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CallKit, {
    onAddPerson: showInvite,
    onStateChange: handleCallStateChange,
    onInvite: handleInvite,
    contactAvatar: contactAvatar,
    groupAvatar: groupAvatar,
    ringingSource: props.ringingSource
  }), /*#__PURE__*/React.createElement(EaseChatContext.Provider, {
    value: props
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'none'
    }
  }, /*#__PURE__*/React.createElement(MessageBar, {
    showinvite: showInviteModal,
    onInviteClose: closeInviteModal,
    confrData: confrData
  })))));
};

var Thread = function Thread(props) {
  return /*#__PURE__*/React.createElement(EaseChatContext.Provider, {
    value: props
  }, /*#__PURE__*/React.createElement(ThreadPanel, null));
};

var EaseChatProvider = function EaseChatProvider(props) {
  var threadPanelStates = useSelector(function (state) {
    var _state$thread;

    return (_state$thread = state.thread) === null || _state$thread === void 0 ? void 0 : _state$thread.threadPanelStates;
  });
  return /*#__PURE__*/React.createElement(Provider, {
    store: store
  }, /*#__PURE__*/React.createElement(React.StrictMode, null, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      height: '100%'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      flex: '1 1 auto',
      height: '100%'
    }
  }, /*#__PURE__*/React.createElement(Chat, props)), /*#__PURE__*/React.createElement("div", {
    style: {
      flex: '0 0 392px',
      overflow: 'hidden',
      display: threadPanelStates ? 'flex' : 'none',
      height: '100%'
    }
  }, /*#__PURE__*/React.createElement("hr", {
    style: {
      width: 0,
      height: '100%',
      border: 'none',
      borderRight: '8px solid #edeff2',
      marginTop: '0px'
    }
  }), /*#__PURE__*/React.createElement(Thread, props)))));
};

EaseChatProvider.getSdk = function (props) {
  if (!WebIM.conn) {
    initIMSDK(props.appkey);
    createlistener(props);
  }

  return WebIM;
};

export default EaseChatProvider;
EaseChatProvider.propTypes = process.env.NODE_ENV !== "production" ? {
  appkey: PropTypes.string,
  username: PropTypes.string,
  agoraToken: PropTypes.string,
  password: PropTypes.string,
  chatType: PropTypes.string,
  to: PropTypes.string,
  showByselfAvatar: PropTypes.bool,
  easeInputMenu: PropTypes.string,
  menuList: PropTypes.array,
  handleMenuItem: PropTypes.func,
  successLoginCallback: PropTypes.func,
  failCallback: PropTypes.func,
  onChatAvatarClick: PropTypes.func,
  isShowReaction: PropTypes.bool,
  customMessageList: PropTypes.array,
  customMessageClick: PropTypes.func,
  onOpenThreadPanel: PropTypes.func,
  agoraUid: PropTypes.string,
  isShowRTC: PropTypes.bool,
  getRTCToken: PropTypes.func,
  getIdMap: PropTypes.func,
  appId: PropTypes.string,
  deleteSessionAndMessage: PropTypes.func
} : {};
EaseChatProvider.defaultProps = {
  showByselfAvatar: false,
  easeInputMenu: 'all',
  isChatThread: false,
  isShowRTC: true,
  menuList: [{
    name: i18next.t('send-image'),
    value: "img",
    key: "1"
  }, {
    name: i18next.t('send-file'),
    value: "file",
    key: "2"
  }, {
    name: i18next.t('send-video'),
    value: "video",
    key: "3"
  }]
};