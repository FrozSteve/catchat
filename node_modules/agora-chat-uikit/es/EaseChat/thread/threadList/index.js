import React, { useState, useEffect, useRef, useContext } from "react";
import ReactDOM from "react-dom";
import { useSelector, useDispatch } from "../../../EaseApp/index";
import { Box, Popover } from "@material-ui/core";
import ThreadActions from "../../../redux/thread";
import { getTimeDiff } from "../../../utils/index";
import close from '../../../common/images/threadClose.png';
import "./index.css";
import avatar from "../../../common/icons/avatar1.jpg"; // import "../../../i18n";

import i18next from "i18next";
import { emoji } from "../../../common/emoji";
import _ from "lodash";
import AppDB from "../../../utils/AppDB";
import { message as Alert } from '../../../EaseChat/common/alert';
import { EaseChatContext } from "../../chat/index";

var ThreadListPanel = function ThreadListPanel(_ref) {
  var anchorEl = _ref.anchorEl,
      onClose = _ref.onClose;
  var easeChatProps = useContext(EaseChatContext);
  var onOpenThreadPanel = easeChatProps.onOpenThreadPanel;
  var dispatch = useDispatch();
  var threadList = useSelector(function (state) {
    var _state$thread;

    return (_state$thread = state.thread) === null || _state$thread === void 0 ? void 0 : _state$thread.threadList;
  }) || [];
  var curGroupRole = useSelector(function (state) {
    var _state$thread2;

    return (_state$thread2 = state.thread) === null || _state$thread2 === void 0 ? void 0 : _state$thread2.curGroupRole;
  }) || '';

  var _useSelector = useSelector(function (state) {
    return state.global.globalProps;
  }),
      chatType = _useSelector.chatType,
      to = _useSelector.to;

  var threadListDom = useRef(null);
  useEffect(function () {
    if (chatType === "groupChat" && anchorEl) {
      var dom = threadListDom.current;

      if (ReactDOM.findDOMNode(dom)) {
        dom.scrollTop = 0;
      }

      dispatch(ThreadActions.setThreadListEnd(false));
      var options = {
        groupId: to,
        limit: 20
      };
      dispatch(ThreadActions.getThreadsListOfGroup(options));
    }
  }, [anchorEl]);

  var renderMessage = function renderMessage(message) {
    switch (message.type) {
      case 'txt':
        return renderTxt(message.msg);

      case 'file':
        return "[" + i18next.t('File') + "]";

      case 'img':
        return "[" + i18next.t('Image') + "]";

      case 'audio':
        return "[" + i18next.t('Audio') + "]";

      case 'video':
        return "[" + i18next.t('Video') + "]";

      default:
        return '';
    }
  };

  var renderTxt = function renderTxt(txt) {
    if (txt === undefined) {
      return [];
    }

    var rnTxt = [];
    var match = null;
    var regex = /(\[.*?\])/g;
    var start = 0;
    var index = 0;

    while (match = regex.exec(txt)) {
      index = match.index;

      if (index > start) {
        rnTxt.push(txt.substring(start, index));
      }

      if (match[1] in emoji.map) {
        var v = emoji.map[match[1]];
        rnTxt.push( /*#__PURE__*/React.createElement("img", {
          key: v + Math.floor(Math.random() * 99 + 1),
          alt: v,
          src: require("../../../common/reactions/" + v)["default"],
          width: 20,
          height: 20
        }));
      } else {
        rnTxt.push(match[1]);
      }

      start = index + match[1].length;
    }

    rnTxt.push(txt.substring(start, txt.length));
    return rnTxt;
  };

  var _useState = useState(false),
      isPullingDown = _useState[0],
      setIsPullingDown = _useState[1];

  var handleScroll = function handleScroll(e) {
    if (e.target.scrollHeight === e.target.scrollTop + e.target.clientHeight) {
      if (!isPullingDown) {
        setIsPullingDown(true);
        setTimeout(function () {
          setIsPullingDown(false);

          if (chatType === "groupChat") {
            var options = {
              groupId: to,
              limit: 20,
              isScroll: true
            };
            dispatch(ThreadActions.getThreadsListOfGroup(options));
          }
        }, 500);
      }
    }
  };

  var openThreadPanel = function openThreadPanel(option) {
    if (curGroupRole === 'member') {
      changeCurrentThreadInfo(option);
    } else {
      WebIM.conn.joinChatThread({
        chatThreadId: option.id
      }).then(function (res) {
        changeCurrentThreadInfo(option);
      })["catch"](function (e) {
        if (e.type === 1301) {
          changeCurrentThreadInfo(option);
        } else if (e.type === 1300) {
          Alert.warn(i18next.t('The thread has been disbanded'));
        }
      });
    }

    onOpenThreadPanel && onOpenThreadPanel(option);
  };

  var changeCurrentThreadInfo = function changeCurrentThreadInfo(option) {
    dispatch(ThreadActions.setCurrentThreadInfo(option)); //updatea setThreadOriginalMsg

    if (option.messageId) {
      AppDB.findLocalMessage('groupChat', option.messageId).then(function (res) {
        var msg = res.length === 1 ? res[0] : {};
        dispatch(ThreadActions.setThreadOriginalMsg(msg));
      });
    } //update the status of creatingThread


    dispatch(ThreadActions.setIsCreatingThread(false)); //open threadPanel

    dispatch(ThreadActions.updateThreadStates(true)); //close threadListPanel

    onClose();
  }; //The list is empty


  var renderDefaultList = function renderDefaultList() {
    if (threadList.length === 0) return /*#__PURE__*/React.createElement(Box, {
      className: "tlp-default-tips"
    }, /*#__PURE__*/React.createElement("div", {
      className: "tlp-tips1"
    }, /*#__PURE__*/React.createElement("span", {
      className: "tlp-tips1-img"
    }), i18next.t('There are no Threads')), /*#__PURE__*/React.createElement("div", {
      className: "tlp-tips2"
    }, i18next.t('Create a Thread from a Group Chat Message')));
  };

  return /*#__PURE__*/React.createElement(Popover, {
    open: Boolean(anchorEl),
    onClose: onClose,
    anchorEl: anchorEl,
    anchorOrigin: {
      vertical: "top",
      horizontal: "right"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "right"
    }
  }, /*#__PURE__*/React.createElement(Box, {
    className: "threadListPanel"
  }, /*#__PURE__*/React.createElement("div", {
    className: "tlp-header-thread"
  }, /*#__PURE__*/React.createElement("span", {
    className: "tlp-header-title"
  }, i18next.t('Threads List')), /*#__PURE__*/React.createElement("div", {
    className: "tlp-header-icon",
    onClick: onClose
  }, /*#__PURE__*/React.createElement("img", {
    className: "tlp-header-icon-close",
    alt: "closeIcon",
    src: close
  }))), /*#__PURE__*/React.createElement("ul", {
    className: "tlp-list",
    ref: threadListDom,
    onScroll: handleScroll
  }, renderDefaultList(), threadList.length > 0 && threadList.map(function (option, index) {
    var _option$lastMessage;

    return /*#__PURE__*/React.createElement("li", {
      className: "tlp-item",
      key: index,
      onClick: function onClick(e) {
        return openThreadPanel(option);
      }
    }, /*#__PURE__*/React.createElement(Box, {
      className: "tpl-item-con"
    }, /*#__PURE__*/React.createElement("div", {
      className: "tpl-item-name"
    }, option.name), /*#__PURE__*/React.createElement(Box, {
      className: "tpl-item-bottom"
    }, /*#__PURE__*/React.createElement("img", {
      className: "tlp-avatar",
      alt: "Remy Sharp",
      src: avatar
    }), /*#__PURE__*/React.createElement("span", {
      className: "tpl-item-owner"
    }, option.owner), option.lastMessage && /*#__PURE__*/React.createElement("span", {
      className: "tpl-item-msg"
    }, renderMessage(option.lastMessage)), /*#__PURE__*/React.createElement("span", {
      className: "tpl-item-time"
    }, getTimeDiff((_option$lastMessage = option.lastMessage) === null || _option$lastMessage === void 0 ? void 0 : _option$lastMessage.time)))));
  }))));
};

export default ThreadListPanel;