function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useCallback, createContext } from "react";
import PropTypes from "prop-types";
import { makeStyles, styled } from "@material-ui/styles";
import Box from "@material-ui/core/Box";
import Grid from "@material-ui/core/Grid";
import Paper from "@material-ui/core/Paper";
import { Provider, createStoreHook, createDispatchHook, createSelectorHook } from "react-redux";
import WebIM, { initIMSDK } from "../utils/WebIM";
import store from "../redux/index";
import GlobalPropsActions from "../redux/globalProps";
import createlistener from "../utils/WebIMListen";
import MessageActions from "../redux/message";
import SessionActions from "../redux/session";
import ThreadActions from "../redux/thread";
import _ from "lodash";
import "../i18n";
import "../common/iconfont.css";
import SessionList from "../EaseChat/session/sessionList";
import EaseChat from "../EaseChat/chat/index";
import { addLocalMessage } from '../utils/WebIMListen';
var uikit_store = React.createContext();
export var useDispatch = createDispatchHook(uikit_store);
export var useSelector = createSelectorHook(uikit_store);
export var EaseAppContext = createContext();
var useStyles = makeStyles(function (theme) {
  return {
    root: {
      width: "100%",
      height: "100%",
      display: "flex"
    },
    grid: {
      backgroundColor: "rgb(237, 239, 242)",
      width: '360px'
    }
  };
});
var Item = styled(Grid)(function (_ref) {
  var theme = _ref.theme;
  return {};
});

var EaseApp = function EaseApp(props) {
  var dispatch = useDispatch(null);
  var classes = useStyles();
  var handleClickItem = useCallback(function (session) {
    props.onConversationClick && props.onConversationClick(session);
    var sessionType = session.sessionType,
        sessionId = session.sessionId,
        name = session.name;

    if (!session.lastMessage) {
      dispatch(MessageActions.fetchMessage(sessionId, sessionType));
    }

    WebIM.conn.getPresenceStatus({
      usernames: [sessionId]
    }).then(function (res) {
      var _presenceExt;

      var extFlag = false;
      var device = '';
      var data = res.result[0].status;
      var dataExt = res.result[0];

      for (var item in data) {
        if (Number(data[item]) === 1) {
          extFlag = true;
          device = item.includes('webim') ? 'Web' : 'Mobile';
        }
      }

      if (!extFlag) {
        dataExt.ext = 'Offline';
      }

      if (!device) {
        device = Object.keys(data).length ? Object.keys(data)[0].includes('webim') ? 'Web' : 'Mobile' : '';
      }

      dispatch(GlobalPropsActions.setGlobalProps({
        to: sessionId,
        chatType: sessionType,
        name: name,
        presenceExt: (_presenceExt = {}, _presenceExt[sessionId] = {
          ext: dataExt.ext,
          device: device
        }, _presenceExt)
      }));
    })["catch"](function (e) {
      console.log(e);
      dispatch(GlobalPropsActions.setGlobalProps({
        to: sessionId,
        chatType: sessionType,
        name: name
      }));
    });
    dispatch(SessionActions.setCurrentSession(sessionId));
    dispatch(MessageActions.clearUnreadAsync(sessionType, sessionId));
    dispatch(ThreadActions.updateThreadStates(false));
    dispatch(ThreadActions.getCurrentGroupRole({
      sessionType: sessionType,
      sessionId: sessionId
    }));
  }, [props.width]);
  return /*#__PURE__*/React.createElement(Box, {
    sx: {
      flexGrow: 1
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      position: "absolute",
      width: "100%",
      height: "calc(100%)"
    }
  }, /*#__PURE__*/React.createElement(Grid, {
    item: true,
    className: classes.grid
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: "100%",
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      width: '360px'
    }
  }, /*#__PURE__*/React.createElement("div", null, props.header), /*#__PURE__*/React.createElement(EaseAppContext.Provider, {
    value: props
  }, /*#__PURE__*/React.createElement(SessionList, {
    onClickItem: handleClickItem
  })))), /*#__PURE__*/React.createElement(Grid, {
    style: {
      width: '100%',
      minWidth: '788px'
    }
  }, /*#__PURE__*/React.createElement(EaseChat, props))));
};

var EaseAppProvider = function EaseAppProvider(props) {
  return /*#__PURE__*/React.createElement(Provider, {
    context: uikit_store,
    store: store
  }, /*#__PURE__*/React.createElement(React.StrictMode, null, /*#__PURE__*/React.createElement(EaseApp, props)));
};

export default EaseAppProvider;

EaseAppProvider.addConversationItem = function (session) {
  if (session && Object.keys(session).length > 0) {
    var _presenceExt2;

    var conversationType = session.conversationType,
        conversationId = session.conversationId,
        conversationName = session.conversationName,
        ext = session.ext,
        firstCrate = session.firstCrate,
        groupText = session.groupText,
        createGroup = session.createGroup;
    var dispatch = store.dispatch;
    var storeSessionList = store.getState().session;
    var sessionList = storeSessionList.sessionList;

    var isNewSession = _.findIndex(sessionList, function (v) {
      return v.sessionId === session.conversationId;
    });

    if (isNewSession === -1) {
      dispatch(SessionActions._pushSession({
        sessionType: session.conversationType,
        sessionId: session.conversationId,
        sessionName: session.conversationName
      }));
      addLocalMessage({
        to: conversationId,
        from: WebIM.conn.context.userId,
        chatType: conversationType,
        groupName: conversationName,
        createGroup: createGroup || true,
        groupText: groupText || "You have created a group",
        firstCrate: firstCrate,
        msgType: conversationType === 'groupChat' ? 'notify' : ''
      });
    }

    dispatch(SessionActions.setCurrentSession(conversationId));
    dispatch(SessionActions.topSession(conversationId, conversationType));
    dispatch(GlobalPropsActions.setGlobalProps({
      to: conversationId,
      chatType: conversationType,
      name: conversationName,
      presenceExt: (_presenceExt2 = {}, _presenceExt2[conversationId] = ext, _presenceExt2)
    }));
    dispatch(MessageActions.clearUnreadAsync(conversationType, conversationId));
    dispatch(ThreadActions.updateThreadStates(false));
    dispatch(ThreadActions.getCurrentGroupRole({
      sessionType: conversationType,
      sessionId: conversationId
    }));
  }
};

EaseAppProvider.changePresenceStatus = function (ext) {
  var dispatch = store.dispatch,
      getState = store.getState;
  dispatch(GlobalPropsActions.setGlobalProps(_extends({}, getState().global.globalProps, {
    presenceExt: ext
  })));
};

EaseAppProvider.getSdk = function (props) {
  if (!WebIM.conn) {
    initIMSDK(props.appkey);
    createlistener(props);
  }

  return WebIM;
};

EaseAppProvider.thread = {
  //是否支持thread功能 默认：否

  /**
   * 
   * @param {boolean} status: thread服务可用状态
   */
  setShowThread: function setShowThread(status) {
    store.dispatch(ThreadActions.setShowThread(status));
  },
  //是否有thread编辑面板，默认：否

  /**
   * 
   * @param {boolean} status 
   */
  setHasThreadEditPanel: function setHasThreadEditPanel(status) {
    store.dispatch(ThreadActions.setHasThreadEditPanel(status));
  },
  //关闭thread面板

  /**
   * @param {boolean} status 
   */
  closeThreadPanel: function closeThreadPanel() {
    store.dispatch(ThreadActions.updateThreadStates(false));
  }
};

EaseAppProvider.deleteSessionAndMessage = function (session) {
  var dispatch = store.dispatch;
  dispatch(MessageActions.clearMessage(session.sessionType, session.sessionId));
  dispatch(SessionActions.deleteSession(session.sessionId));
  dispatch(GlobalPropsActions.setGlobalProps({
    to: null
  }));
};

EaseAppProvider.propTypes = process.env.NODE_ENV !== "production" ? {
  username: PropTypes.string,
  agoraToken: PropTypes.string,
  password: PropTypes.string,
  appkey: PropTypes.string,
  // custom header component
  header: PropTypes.node,
  // addConversationItem: PropTypes.func,
  // show unread message count in conversation list
  isShowUnread: PropTypes.bool,
  // true: unread count; false: red dot
  unreadType: PropTypes.bool,
  // callback of click conversation item
  onConversationClick: PropTypes.func,
  // Whether to show my own avatar in message item
  showByselfAvatar: PropTypes.bool,
  // sendBox support all， noAudio， noEmoji， noAudioAndEmoji， onlyText
  easeInputMenu: PropTypes.string,
  // sendBox more menu options: image file video
  menuList: PropTypes.array,
  // callback of click sendBox more menu item
  handleMenuItem: PropTypes.func,
  // callback of click chat component message bar avatar
  onChatAvatarClick: PropTypes.func,
  // Whether to show reaction
  isShowReaction: PropTypes.bool,
  // message operation menu options
  customMessageList: PropTypes.array,
  // callback of click message operation menu options item
  customMessageClick: PropTypes.func,
  //thread-click edit panel,get thread info
  onEditThreadPanel: PropTypes.func,
  onOpenThreadPanel: PropTypes.func,
  agoraUid: PropTypes.string,
  getRTCToken: PropTypes.func,
  isShowRTC: PropTypes.bool,
  getIdMap: PropTypes.func,
  appId: PropTypes.string,
  deleteSessionAndMessage: PropTypes.func
} : {};
EaseAppProvider.defaultProps = {
  isShowUnread: true,
  unreadType: true
};