var _createReducer;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { formatLocalMessage, formatServerMessage } from "../utils/index";
import { createReducer, createActions } from "reduxsauce";
import Immutable from "seamless-immutable";
import _ from "lodash"; // import store from '../redux/index'

import WebIM from "../utils/WebIM";
import AppDB from "../utils/AppDB";
import i18next from "i18next";
import { message } from '../EaseChat/common/alert';

function isAdded(reactionOp) {
  var added = null;
  var currentLoginUser = WebIM.conn.context.userId;
  reactionOp.forEach(function (item) {
    if (item.reactionType === "create") {
      if (item.operator === currentLoginUser) {
        added = true;
      }
    } else {
      if (item.operator === currentLoginUser) {
        added = false;
      }
    }
  });
  return added;
}
/* ------------- Initial State ------------- */


export var INITIAL_STATE = Immutable({
  byId: {},
  singleChat: {},
  groupChat: {},
  chatRoom: {},
  stranger: {},
  threadMessage: {},
  extra: {},
  unread: {
    singleChat: {},
    groupChat: {},
    chatRoom: {},
    stranger: {}
  },
  threadHistoryStart: -1,
  threadHasHistory: true
});
/* -------- Types and Action Creators -------- */

var _createActions = createActions({
  addMessage: ["message", "messageType"],
  deleteMessage: ["msgId", "to", "chatType"],
  updateMessageStatus: ["message", "status", "localId", "serverMsgId"],
  clearUnread: ["chatType", "sessionId"],
  updateMessages: ["chatType", "sessionId", "messages"],
  updateReactionData: ["message", "reaction"],
  updateMessageMid: ['id', 'mid', 'to'],
  updateThreadDetails: ['chatType', 'options', 'messageList'],
  updateThreadMessage: ['to', 'messageList', 'isScroll'],
  setThreadHistoryStart: ['start'],
  setThreadHasHistory: ['status'],
  updateNotifyDetails: ["formatMsg"],
  // -async-
  sendTxtMessage: function sendTxtMessage(to, chatType, message, isChatThread) {
    if (message === void 0) {
      message = {};
    }

    if (isChatThread === void 0) {
      isChatThread = false;
    }

    if (!to || !chatType) return;
    return function (dispatch, getState) {
      var formatMsg = formatLocalMessage(to, chatType, message, 'txt', isChatThread);
      var msg = formatMsg.body.msg;
      var option = {
        chatType: chatType,
        type: 'txt',
        to: to,
        msg: msg,
        isChatThread: isChatThread
      };
      var msgObj = WebIM.message.create(option);
      formatMsg.id = msgObj.id;
      WebIM.conn.send(msgObj).then(function (res) {
        console.log("send private text Success", res);
        var localMsgId = res.localMsgId,
            serverMsgId = res.serverMsgId;
        dispatch(Creators.updateMessageStatus(formatMsg, "sent", localMsgId, serverMsgId));
      })["catch"](function (e) {
        console.log("Send private text error", e);
        dispatch(Creators.updateMessageStatus(formatMsg, "fail", msgObj.id));
      });
      dispatch(Creators.addMessage(formatMsg));
    };
  },
  sendFileMessage: function sendFileMessage(to, chatType, file, fileEl, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    return function (dispatch, getState) {
      if (file.data.size > 1024 * 1024 * 10) {
        message.error(i18next.t('The file exceeds the upper limit'));
        return;
      }

      var formatMsg = formatLocalMessage(to, chatType, file, 'file', isChatThread);
      var option = {
        chatType: chatType,
        type: "file",
        to: to,
        file: file,
        filename: file.filename,
        isChatThread: isChatThread,
        ext: {
          file_length: file.data.size,
          file_type: file.data.type
        },
        onFileUploadError: function onFileUploadError(e) {
          console.log("onFileUploadError", e);
          formatMsg.status = "fail";
          dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
          fileEl.current.value = "";
        },
        onFileUploadProgress: function onFileUploadProgress(progress) {
          console.log(progress);
        },
        onFileUploadComplete: function onFileUploadComplete(data) {
          console.log("onFileUploadComplete");
          var url = data.uri + '/' + data.entities[0].uuid;
          formatMsg.url = formatMsg.body.url = url;
          var type = isChatThread ? 'threadMessage' : chatType;
          dispatch(Creators.updateMessages(type, to, formatMsg));
          fileEl.current.value = '';
        }
      };
      var msg = WebIM.message.create(option);
      formatMsg.id = msg.id;
      WebIM.conn.send(msg).then(function (res) {
        var localMsgId = res.localMsgId,
            serverMsgId = res.serverMsgId;
        console.log("success");
        formatMsg.status = "sent";
        dispatch(Creators.updateMessageStatus(formatMsg, "sent", localMsgId, serverMsgId));
        fileEl.current.value = "";
      })["catch"](function (e) {
        console.log("fail", e);
        dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
        fileEl.current.value = "";
      });
      dispatch(Creators.addMessage(formatMsg, 'file'));
    };
  },
  sendImgMessage: function sendImgMessage(to, chatType, file, imageEl, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    return function (dispatch, getState) {
      if (file.data.size > 1024 * 1024 * 10) {
        message.error(i18next.t('The file exceeds the upper limit'));
        return;
      }

      var formatMsg = formatLocalMessage(to, chatType, file, 'img', isChatThread);
      var option = {
        chatType: chatType,
        type: "img",
        to: to,
        file: file,
        isChatThread: isChatThread,
        onFileUploadError: function onFileUploadError() {
          console.log("onFileUploadError");
          formatMsg.status = "fail";
          dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
          imageEl.current.value = "";
        },
        onFileUploadProgress: function onFileUploadProgress(progress) {
          console.log(progress);
        },
        onFileUploadComplete: function onFileUploadComplete(data) {
          console.log("onFileUploadComplete", data);
          var url = data.uri + "/" + data.entities[0].uuid;
          formatMsg.url = url;
          formatMsg.body.url = url;
          formatMsg.thumb = data.thumb;
          formatMsg.body.thumb = data.thumb;
          var type = isChatThread ? 'threadMessage' : chatType;
          dispatch(Creators.updateMessages(type, to, formatMsg));
          imageEl.current.value = "";
        }
      };
      var msg = WebIM.message.create(option);
      formatMsg.id = msg.id;
      WebIM.conn.send(msg).then(function (res) {
        console.log("Success");
        var localMsgId = res.localMsgId,
            serverMsgId = res.serverMsgId;
        formatMsg.status = "sent";
        dispatch(Creators.updateMessageStatus(formatMsg, "sent", localMsgId, serverMsgId));
      })["catch"](function (e) {
        console.log("Fail");
        dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
        imageEl.current.value = "";
      });
      dispatch(Creators.addMessage(formatMsg, 'img'));
    };
  },
  sendVideoMessage: function sendVideoMessage(to, chatType, file, videoEl, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    return function (dispatch, getState) {
      if (file.data.size > 1024 * 1024 * 10) {
        message.error(i18next.t('The video exceeds the upper limit'));
        return;
      }

      var allowType = {
        'mp4': true,
        'wmv': true,
        'avi': true,
        'rmvb': true,
        'mkv': true
      };

      if (file.filetype.toLowerCase() in allowType) {
        var formatMsg = formatLocalMessage(to, chatType, file, "video", isChatThread);
        var option = {
          chatType: chatType,
          type: "video",
          to: to,
          file: file,
          filename: file.filename,
          isChatThread: isChatThread,
          ext: {
            file_length: file.data.size,
            file_type: file.data.type
          },
          onFileUploadError: function onFileUploadError() {
            console.log("onFileUploadError");
            formatMsg.status = "fail";
            dispatch(Creators.updateMessageStatus(formatMsg, "fail", _msg.id));
            videoEl.current.value = "";
          },
          onFileUploadProgress: function onFileUploadProgress(e) {
            console.log(e);
          },
          onFileUploadComplete: function onFileUploadComplete(data) {
            console.log("onFileUploadComplete");
            var url = data.uri + "/" + data.entities[0].uuid;
            formatMsg.url = url;
            formatMsg.body.url = url;
            var type = isChatThread ? 'threadMessage' : chatType;
            dispatch(Creators.updateMessages(type, to, formatMsg));
            videoEl.current.value = "";
          }
        };

        var _msg = WebIM.message.create(option);

        formatMsg.id = _msg.id;
        WebIM.conn.send(_msg).then(function (res) {
          console.log("Success");
          var localMsgId = res.localMsgId,
              serverMsgId = res.serverMsgId;
          formatMsg.status = "sent";
          dispatch(Creators.updateMessageStatus(formatMsg, "sent", localMsgId, serverMsgId));
        })["catch"](function (e) {
          console.log("Fail");
          dispatch(Creators.updateMessageStatus(formatMsg, "fail", _msg.id));
          videoEl.current.value = "";
        });
        dispatch(Creators.addMessage(formatMsg, "video"));
      }
    };
  },
  sendRecorder: function sendRecorder(to, chatType, file, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    return function (dispatch, getState) {
      if (file.data.size > 1024 * 1024 * 10) {
        message.error(i18next.t("The file exceeds the upper limit"));
        return;
      }

      var formatMsg = formatLocalMessage(to, chatType, file, "audio", isChatThread);
      var option = {
        chatType: chatType,
        type: "audio",
        to: to,
        file: file,
        filename: file.filename,
        length: file.length,
        isChatThread: isChatThread,
        ext: {
          file_length: file.data.size,
          file_type: file.data.type,
          length: file.length,
          duration: file.duration
        },
        onFileUploadError: function onFileUploadError(error) {
          console.log("onFileUploadError", error);
          formatMsg.status = "fail";
          dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
        },
        onFileUploadProgress: function onFileUploadProgress(e) {
          console.log(e);
        },
        onFileUploadComplete: function onFileUploadComplete(data) {
          console.log("onFileUploadComplete");
          var url = data.uri + "/" + data.entities[0].uuid;
          formatMsg.url = url;
          formatMsg.body.url = url;
          var type = isChatThread ? 'threadMessage' : chatType;
          dispatch(Creators.updateMessages(type, to, formatMsg));
        }
      };
      var msg = WebIM.message.create(option);
      formatMsg.id = msg.id;
      WebIM.conn.send(msg).then(function (res) {
        console.log("success");
        var localMsgId = res.localMsgId,
            serverMsgId = res.serverMsgId;
        formatMsg.status = "sent";
        dispatch(Creators.updateMessageStatus(formatMsg, "sent", localMsgId, serverMsgId));
      })["catch"](function (e) {
        console.log("fail");
        dispatch(Creators.updateMessageStatus(formatMsg, "fail", msg.id));
      });
      dispatch(Creators.addMessage(formatMsg, "audio"));
    };
  },
  recallMessage: function recallMessage(to, chatType, msg, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    return function (dispatch, getState) {
      var id = msg.id,
          toJid = msg.toJid,
          mid = msg.mid;
      WebIM.conn.recallMessage({
        to: to,
        mid: toJid || mid || id,
        // message id
        type: chatType,
        isChatThread: isChatThread,
        success: function success() {
          dispatch(Creators.deleteMessage(id, to, chatType));
        },
        fail: function fail(err) {
          console.log(err);
        }
      });
    };
  },
  clearUnreadAsync: function clearUnreadAsync(chatType, sessionId) {
    return function (dispatch) {
      dispatch({
        'type': 'CLEAR_UNREAD',
        chatType: chatType,
        sessionId: sessionId
      });
      AppDB.readMessage(chatType, sessionId);
    };
  },
  fetchMessage: function fetchMessage(to, chatType, offset, cb) {
    return function (dispatch) {
      AppDB.fetchMessage(to, chatType, offset).then(function (res) {
        if (res.length) {
          dispatch({
            'type': 'FETCH_MESSAGE',
            'chatType': chatType,
            'to': to,
            'messages': res
          });
        }

        cb && cb(res.length);
      });
    };
  },
  fetchThreadMessage: function fetchThreadMessage(to, cb, isScroll) {
    var username = WebIM.conn.context.userId;
    return function (dispatch, getState) {
      var rootState = getState();
      if (!rootState.message.threadHasHistory && isScroll) return;
      var options = {
        targetId: to,
        cursor: isScroll ? rootState.message.threadHistoryStart : -1,
        pageSize: 20,
        chatType: 'groupChat',
        searchDirection: 'down'
      };
      WebIM.conn.getHistoryMessages(options).then(function (res) {
        var msgList = res.messages;

        if (msgList.length < options.pageSize || msgList.length === 0) {
          dispatch(Creators.setThreadHasHistory(false));
        }

        var newMsgList = [];

        if (msgList.length > 0) {
          msgList.forEach(function (item) {
            var msg = formatServerMessage(item, item.type);
            msg.bySelf = msg.from === username;
            newMsgList.push(msg);
          });
          dispatch(Creators.setThreadHistoryStart(res.cursor));
          dispatch(Creators.updateThreadMessage(to, newMsgList, isScroll));
        }

        cb && cb(newMsgList.length);
      });
    };
  },
  clearMessage: function clearMessage(chatType, id) {
    return function (dispatch) {
      dispatch({
        'type': 'CLEAR_MESSAGE',
        'chatType': chatType,
        'id': id
      });
      AppDB.clearMessage(chatType, id).then(function (res) {});
    };
  },
  addAudioMessage: function addAudioMessage(message, bodyType) {
    return function (dispatch, getState) {
      var options = {
        url: message.url,
        headers: {
          Accept: "audio/mp3"
        },
        onFileDownloadComplete: function onFileDownloadComplete(response) {
          var objectUrl = WebIM.utils.parseDownloadResponse.call(WebIM.conn, response);
          message.audioSrcUrl = message.url;
          message.url = objectUrl;
          dispatch(Creators.addMessage(message, bodyType));
        },
        onFileDownloadError: function onFileDownloadError() {}
      };
      WebIM.utils.download.call(WebIM.conn, options);
    };
  },
  addReactions: function addReactions(msg, reaction) {
    return function (dispatch, getState) {
      WebIM.conn.addReaction({
        messageId: msg.id,
        reaction: reaction
      }).then(function (res) {
        console.log('msg', msg, reaction);
        var reactions = JSON.parse(JSON.stringify(msg.reactions || [])) || [];
        var findItem = reactions.find(function (item) {
          return item.reaction === reaction;
        });

        if (findItem) {
          findItem.count++;
          isAddedBySelf = true;
          findItem.userList.push(WebIM.conn.context.userId);
        } else {
          reactions.push({
            count: 1,
            reaction: reaction,
            isAddedBySelf: true,
            userList: [WebIM.conn.context.userId]
          });
        } // msg.reactions = reactions


        // msg.reactions = reactions
        var newMsg = Object.assign({}, msg);
        newMsg.reactions = reactions;
        dispatch(Creators.updateReactionData(newMsg, reactions));
      })["catch"](function (e) {
        console.log('add reaction fail', e);
        message.error('add reaction fail');
      });
    };
  },
  deleteReaction: function deleteReaction(msg, reaction) {
    return function (dispatch, getState) {
      WebIM.conn.deleteReaction({
        messageId: msg.id,
        reaction: reaction
      }).then(function () {
        console.log('msg', msg);
        var reactions = JSON.parse(JSON.stringify(msg.reactions || []));
        reactions.forEach(function (item) {
          if (item.reaction === reaction) {
            item.count--;
            item.isAddedBySelf = false;
            item.userList = item.userList.filter(function (user) {
              return user !== WebIM.conn.context.userId;
            });
          }
        });
        var newMsg = Object.assign({}, msg);
        newMsg.reactions = reactions;
        dispatch(Creators.updateReactionData(newMsg));
      })["catch"](function (e) {
        console.log('delete reaction fail', e);
        message.error('delete reaction fail');
      });
    };
  },
  updateReaction: function updateReaction(message) {
    var messageId = message.messageId,
        chatType = message.chatType,
        from = message.from,
        to = message.to,
        reactions = message.reactions;
    return function (dispatch, getState) {
      var state = getState().message;
      var byId = state.getIn(["byId", messageId]);

      if (!byId && messageId) {
        AppDB.findMessageById(messageId).then(function (res) {
          var dbMessage = res[0];
          var msgReactions = (dbMessage === null || dbMessage === void 0 ? void 0 : dbMessage.reactions) || []; // if(!msgReactions) return;

          // if(!msgReactions) return;
          var newReactions = [];
          reactions.map(function (item) {
            var reactionOp = item.op || [];
            var added = isAdded(reactionOp);
            msgReactions.forEach(function (msgReaction) {
              if (msgReaction.reaction === item.reaction && msgReaction.isAddedBySelf) {
                item.isAddedBySelf = msgReaction.isAddedBySelf;
              }
            });

            if (added) {
              item.isAddedBySelf = true;
            } else if (added === false) {
              item.isAddedBySelf = false;
            }

            if (item.count > 0) {
              newReactions.push(item);
            }
          });
          dispatch(Creators.updateReactionData(message, newReactions));
        });
      } else {
        dispatch(Creators.updateReactionData(message));
      }
    };
  },
  addNotify: function addNotify(message, notifyType) {
    var from = message.from,
        gid = message.gid;
    return function (dispatch, getState) {
      var formatMsg = formatLocalMessage(gid, notifyType, message, 'notify');
      formatMsg.from = from;
      formatMsg.type = 'notify';
      console.log(formatMsg, 'formatMsg');
      dispatch(Creators.updateNotifyDetails(formatMsg));
    };
  },
  sendCmdMessage: function sendCmdMessage(to, chatType, action, isChatThread) {
    if (isChatThread === void 0) {
      isChatThread = false;
    }

    if (!to || !chatType) return;
    return function (dispatch, getState) {
      var formatMsg = formatLocalMessage(to, chatType, action, 'cmd', isChatThread);
      var msg = formatMsg.body.msg;
      var option = {
        chatType: chatType,
        type: 'cmd',
        to: to,
        msg: msg,
        isChatThread: isChatThread,
        action: action
      };
      var msgObj = WebIM.message.create(option);
      formatMsg.id = msgObj.id;
      WebIM.conn.send(msgObj).then(function (res) {
        console.log("send private text Success", res);
      })["catch"](function (e) {
        console.log("Send private text error", e);
      });
    };
  }
}),
    Types = _createActions.Types,
    Creators = _createActions.Creators;
/* ------------- Reducers ------------- */


export var addMessage = function addMessage(state, _ref) {
  var message = _ref.message,
      _ref$messageType = _ref.messageType,
      messageType = _ref$messageType === void 0 ? "txt" : _ref$messageType;
  var rootState = state;
  !message.status && (message = formatServerMessage(message, messageType));
  var username = WebIM.conn.context.userId;
  var _message2 = message,
      id = _message2.id,
      to = _message2.to,
      status = _message2.status,
      isChatThread = _message2.isChatThread,
      chatThread = _message2.chatThread;
  var _message3 = message,
      chatType = _message3.chatType;
  var from = message.from || username;
  var bySelf = from === username;
  var chatId = bySelf || chatType !== "singleChat" ? to : from;

  if (isChatThread || chatThread && JSON.stringify(chatThread) !== '{}') {
    if (state.threadHasHistory) return state; //The message is sent byself when isChatThread is true or the chatThread is not null when receiving a thread message
    //save the thread message  indexDB & threadMessageList

    var _chatData = state.getIn(['threadMessage', chatId], Immutable([])).asMutable();

    var _message4 = _extends({}, message, {
      bySelf: bySelf,
      isChatThread: true,
      //is thread message
      time: +new Date(),
      status: status
    });

    var _isPushed = false;

    _chatData.forEach(function (m) {
      if (m.id === _message4.id) {
        _isPushed = true;
      }
    });

    !_isPushed && _chatData.push(_message4);
    state = state.setIn(['threadMessage', chatId], _chatData);
    !_isPushed && AppDB.addMessage(_message4, !bySelf ? 1 : 0, isChatThread);
    state = state.setIn(["byId", id], {
      chatType: chatType,
      chatId: chatId
    });
    return state;
  }

  var chatData = state.getIn([chatType, chatId], Immutable([])).asMutable();

  var _message = _extends({}, message, {
    bySelf: bySelf,
    time: +new Date(),
    status: status
  });

  if (_message.chatType === "chatRoom" && bySelf) {
    var oid = state.getIn(["byMid", _message.id, "id"]);

    if (oid) {
      _message.id = oid;
    }
  }

  var isPushed = false;
  chatData.forEach(function (m) {
    if (m.id === _message.id) {
      isPushed = true;
    }
  });
  console.log(_message, '_message');
  !isPushed && chatData.push(_message); // add a message to db, if by myselt, isUnread equals 0

  !isPushed && AppDB.addMessage(_message, !bySelf ? 1 : 0);
  var maxCacheSize = _.includes(["groupChat", "chatRoom"], chatType) ? WebIM.config.groupMessageCacheSize : WebIM.config.p2pMessageCacheSize;

  if (chatData.length > maxCacheSize) {
    var deletedChats = chatData.splice(maxCacheSize, chatData.length - maxCacheSize);
    var byId = state.getIn(["byId"]);
    byId = _.omit(byId, _.map(deletedChats, "id"));
    state = state.setIn(["byId"], byId);
  }

  state = state.setIn([chatType, chatId], chatData); // unread

  var currentSession = _.get(rootState, ["session", "currentSession"]);

  var addSingleChatUnread = !bySelf && !isPushed && message.from !== currentSession && (chatType === "singleChat" || chatType === "strager");
  var addGroupUnread = !bySelf && !isPushed && message.to !== currentSession && (chatType === "groupChat" || chatType === "chatRoom");

  if (addSingleChatUnread || addGroupUnread) {
    var count = state.getIn(["unread", chatType, chatId], 0);
    state = state.setIn(["unread", chatType, chatId], ++count);
  }

  state = state.setIn(["byId", id], {
    chatType: chatType,
    chatId: chatId
  });
  return state;
};
export var updateThreadMessage = function updateThreadMessage(state, _ref2) {
  var to = _ref2.to,
      messageList = _ref2.messageList,
      isScroll = _ref2.isScroll;
  var data = state['threadMessage'][to] ? state['threadMessage'][to].asMutable() : [];
  data = data.concat(messageList);

  if (isScroll === "scroll") {
    state = state.setIn(['threadMessage', to], data);
  } else {
    state = state.setIn(['threadMessage'], {});
    state = state.setIn(['threadMessage', to], messageList);
  }

  return state;
};
export var updateMessageStatus = function updateMessageStatus(state, _ref3) {
  var message = _ref3.message,
      _ref3$status = _ref3.status,
      status = _ref3$status === void 0 ? "" : _ref3$status,
      localId = _ref3.localId,
      serverMsgId = _ref3.serverMsgId;
  console.log(message, status, localId, serverMsgId, 'messages', state);
  var id = localId;
  var byId = state.getIn(["byId", id]);

  if (!_.isEmpty(byId)) {
    var chatType = byId.chatType,
        chatId = byId.chatId;
    var messages = [];

    if (message.isChatThread) {
      messages = state.getIn(['threadMessage', chatId]).asMutable();
    } else {
      messages = state.getIn([chatType, chatId]).asMutable();
    }

    var found = _.find(messages, {
      id: id
    }) || _.find(messages, {
      id: serverMsgId
    });

    console.log(found, 'found');
    found.setIn(["status"], status);

    var _msg2 = _extends({}, found, {
      status: status
    });

    messages.splice(messages.indexOf(found), 1, _msg2);
    AppDB.updateMessageStatus(id, serverMsgId, status).then(function (res) {
      if (res === 0) {
        AppDB.updateMessageStatus(serverMsgId, id, status).then(function (val) {
          if (val === 0) {
            AppDB.updateMessageStatus(id, serverMsgId, status).then(function (value) {
              console.log(value);
            });
          }
        });
      }
    });

    if (message.isChatThread) {
      state = state.setIn(['threadMessage', chatId], messages);
    } else {
      state = state.setIn([chatType, chatId], messages);
    }

    return state;
  }

  return state;
};
export var deleteMessage = function deleteMessage(state, _ref4) {
  var msgId = _ref4.msgId,
      to = _ref4.to,
      chatType = _ref4.chatType;
  msgId = msgId.mid || msgId;
  var byId = state.getIn(["byId", msgId]);
  var sessionType, chatId; //update the mid of  thread message 

  if (state.threadMessage[to]) {
    var threadMsg = {};
    var threadMsgList = state.getIn(['threadMessage', to]).asMutable({
      deep: true
    });
    threadMsg = _.find(threadMsgList, {
      id: msgId
    });

    var _index = threadMsgList.indexOf(threadMsg); //update threadMessageList and indexDB


    if (threadMsg && threadMsg.id) {
      threadMsgList.splice(_index, 1, _extends({}, threadMsg, {
        body: _extends({}, threadMsg.body, {
          type: "recall"
        })
      }));
      state = state.setIn(['threadMessage', to], threadMsgList);
      AppDB.deleteMessage(msgId);
      return state;
    }
  }

  if (!byId) {
    return state;
  } else {
    sessionType = byId.chatType;
    chatId = byId.chatId;
  }

  var messages = state.getIn([sessionType, chatId]).asMutable() || [];

  var targetMsg = _.find(messages, {
    id: msgId
  });

  var index = messages.indexOf(targetMsg);
  messages.splice(index, 1, _extends({}, targetMsg, {
    body: _extends({}, targetMsg.body, {
      type: "recall"
    })
  }));
  state = state.setIn([sessionType, chatId], messages);
  AppDB.deleteMessage(msgId);
  return state;
};
export var clearUnread = function clearUnread(state, _ref5) {
  var chatType = _ref5.chatType,
      sessionId = _ref5.sessionId;
  var data = state["unread"][chatType].asMutable();
  delete data[sessionId];
  return state.setIn(["unread", chatType], data);
};
export var fetchMessage = function fetchMessage(state, _ref6) {
  var to = _ref6.to,
      chatType = _ref6.chatType,
      messages = _ref6.messages,
      offset = _ref6.offset;
  var data = state[chatType] && state[chatType][to] ? state[chatType][to].asMutable() : [];
  data = messages.concat(data);
  var historyById = {};
  messages.forEach(function (item) {
    historyById[item.id] = {
      chatId: chatType === "singleChat" ? item.from : item.to,
      chatType: item.chatType
    };
  });
  state = state.merge({
    byId: historyById
  });
  state = state.setIn([chatType, to], data);
  return state;
};
export var clearMessage = function clearMessage(state, _ref7) {
  var chatType = _ref7.chatType,
      id = _ref7.id;
  return chatType ? state.setIn([chatType, id], []) : state;
};
export var updateMessages = function updateMessages(state, _ref8) {
  var chatType = _ref8.chatType,
      sessionId = _ref8.sessionId,
      messages = _ref8.messages;
  var messagesArr = state.getIn([chatType, sessionId]).asMutable({
    deep: true
  });
  messagesArr.forEach(function (msg, index) {
    if (msg.id === messages.id) {
      messages.bySelf = true;
      messagesArr.splice(index, 1, messages);
      AppDB.updateMessageUrl(msg.id, messages.url);
    }
  });
  return state.setIn([chatType, sessionId], messagesArr);
};
export var updateMessageMid = function updateMessageMid(state, _ref9) {
  var id = _ref9.id,
      mid = _ref9.mid,
      to = _ref9.to;

  if (state.threadMessage[to]) {
    var threadMsg = {};
    var threadMsgList = state.getIn(['threadMessage', to]).asMutable({
      deep: true
    });
    threadMsg = _.find(threadMsgList, {
      id: id
    });

    if (threadMsg && threadMsg.id) {
      threadMsg.toJid = mid;
      threadMsg.id = mid;
      state = state.setIn(['threadMessage', to], threadMsgList);
    }

    AppDB.updateMessageMid(mid, id);
    return state;
  }

  var byId = state.getIn(["byId", id]);
  if (!byId) return state; // callkit 发的消息 uikit拿不到 id

  if (!_.isEmpty(byId)) {
    var chatType = byId.chatType,
        chatId = byId.chatId;
    var messages = state.getIn([chatType, chatId]).asMutable({
      deep: true
    });

    var found = _.find(messages, {
      id: id
    });

    found.id = mid;
    found.toJid = mid;
    found.mid = mid; // let msg = found.setIn(['toJid'], mid)

    messages.splice(messages.indexOf(found), 1, found);
    state = state.setIn([chatType, chatId], messages);
    state = state.setIn(["byMid", mid], {
      id: id
    });
    state = state.setIn(["byId", mid], {
      chatType: chatType,
      chatId: chatId
    });
  }

  AppDB.updateMessageMid(mid, id);
  return state;
};
export var updateReactionData = function updateReactionData(state, _ref10) {
  var message = _ref10.message,
      reaction = _ref10.reaction;
  console.log('updateReactionData>>>', message, reaction);
  var messageId = message.messageId,
      from = message.from,
      to = message.to,
      reactions = message.reactions,
      chatType = message.chatType;
  var newReactionsData = reactions;
  var currentLoginUser = WebIM.conn.context.userId;
  var addReactionUser = currentLoginUser === from ? to : from;

  if (chatType === 'groupChat') {
    addReactionUser = to;
  }

  if (!messageId) messageId = state.getIn(["byMid", message.mid, "messageId"]) || message.mid;
  var mids = state.getIn(["byMid"]) || {};
  var mid;

  for (var i in mids) {
    if (mids[i].messageId === messageId) {
      mid = i;
    }
  }

  var byId = state.getIn(["byId", messageId]);

  function calculateUserList(reactions) {
    if (reactions === void 0) {
      reactions = [];
    }

    reactions.forEach(function (item) {
      if (item.op) {
        item.op.forEach(function (operator) {
          if (operator.reactionType === 'create' && !item.userList.includes(operator.operator)) {
            item.userList.push(operator.operator);
          }

          if (operator.reactionType === 'delete') {
            item.userList.forEach(function (user, index) {
              if (user === operator.operator) {
                item.userList.splice(index, 1);
              }
            });
          }
        });
      }
    });
  }

  function mergeArray(arr1, arr2) {
    var _arr = new Array();

    for (var i = 0; i < arr1.length; i++) {
      _arr.push(arr1[i]);
    }

    for (var i = 0; i < arr2.length; i++) {
      var flag = true;

      for (var j = 0; j < arr1.length; j++) {
        if (arr2[i] === arr1[j]) {
          flag = false;
          break;
        }
      }

      if (flag) {
        _arr.push(arr2[i]);
      }
    }

    return _arr;
  }

  var isThreadMessage = state.threadMessage[to] ? true : false;

  if (byId || isThreadMessage) {
    var messages = {};
    var _chatType = '';

    if (isThreadMessage) {
      _chatType = message.chatType;
      messages = state.getIn(['threadMessage', to]).asMutable({
        deep: true
      });
    } else {
      _chatType = byId.chatType;
      messages = state.getIn([_chatType, addReactionUser]).asMutable();
    } // const { chatType } = byId;
    // let messages = state.getIn([chatType, addReactionUser]).asMutable();


    var found = _.find(messages, {
      id: messageId
    });

    var _reactions = found.reactions;
    var newReactions = [];
    newReactionsData.map(function (item) {
      var reactionOp = (item === null || item === void 0 ? void 0 : item.op) || [];
      var added = isAdded(reactionOp);
      _reactions && _reactions.forEach(function (msgReaction) {
        if (msgReaction.reaction === item.reaction) {
          item.userList = mergeArray(item.userList, msgReaction.userList);

          if (msgReaction.isAddedBySelf) {
            item.isAddedBySelf = msgReaction.isAddedBySelf;
          }
        }
      });

      if (added) {
        item.isAddedBySelf = true;
      } else if (added === false) {
        item.isAddedBySelf = false;
      }

      if (item.count > 0) {
        newReactions.push(item);
      }
    });
    calculateUserList(newReactions);

    var _msg3 = _extends({}, found, {
      reactions: newReactions
    });

    messages.splice(messages.indexOf(found), 1, _msg3);
    AppDB.updateMessageReaction(messageId, _msg3.reactions).then(function (res) {});

    if (isThreadMessage) {
      state = state.setIn(['threadMessage', to], messages);
    } else {
      state = state.setIn([_chatType, addReactionUser], messages);
    }

    return state; // return state.setIn([chatType, addReactionUser], messages);
  } else {
    calculateUserList(reaction); // state 里没有这条消息，更新数据库里消息的 reation

    AppDB.updateMessageReaction(messageId, reaction);
  }

  return state;
};
export var updateThreadDetails = function updateThreadDetails(state, _ref11) {
  var chatType = _ref11.chatType,
      options = _ref11.options,
      messageList = _ref11.messageList;
  var operation = options.operation,
      parentId = options.parentId;

  if (operation === 'create') {
    var formatMsg = formatLocalMessage(parentId, chatType, {}, 'threadNotify');

    var _message5 = _extends({}, formatMsg, {
      from: options.operator,
      name: options.name,
      time: options.createTimestamp,
      threadId: options.id
    });

    messageList.push(_message5);
    AppDB.addMessage(_message5);
  }

  return state.setIn([chatType, parentId], messageList);
};
export var setThreadHistoryStart = function setThreadHistoryStart(state, _ref12) {
  var start = _ref12.start;
  return state.setIn(['threadHistoryStart'], start);
};
export var setThreadHasHistory = function setThreadHasHistory(state, _ref13) {
  var status = _ref13.status;
  return state.setIn(['threadHasHistory'], status);
};
export var updateNotifyDetails = function updateNotifyDetails(state, _ref14) {
  var formatMsg = _ref14.formatMsg;
  var chatType = formatMsg.chatType,
      to = formatMsg.to,
      id = formatMsg.id,
      type = formatMsg.type;
  var messageList = state[chatType] && state[chatType][to] ? state[chatType][to].asMutable({
    deep: true
  }) : [];

  var message = _extends({}, formatMsg, {
    body: {
      type: type
    }
  });

  AppDB.addMessage(message);
  messageList.push(message);
  state = state.setIn([chatType, to], messageList);
  return state;
};
/* ------------- Hookup Reducers To Types ------------- */

export var messageReducer = createReducer(INITIAL_STATE, (_createReducer = {}, _createReducer[Types.ADD_MESSAGE] = addMessage, _createReducer[Types.DELETE_MESSAGE] = deleteMessage, _createReducer[Types.CLEAR_UNREAD] = clearUnread, _createReducer[Types.FETCH_MESSAGE] = fetchMessage, _createReducer[Types.CLEAR_MESSAGE] = clearMessage, _createReducer[Types.UPDATE_MESSAGES] = updateMessages, _createReducer[Types.UPDATE_MESSAGE_MID] = updateMessageMid, _createReducer[Types.UPDATE_MESSAGE_STATUS] = updateMessageStatus, _createReducer[Types.UPDATE_THREAD_DETAILS] = updateThreadDetails, _createReducer[Types.UPDATE_THREAD_MESSAGE] = updateThreadMessage, _createReducer[Types.SET_THREAD_HISTORY_START] = setThreadHistoryStart, _createReducer[Types.SET_THREAD_HAS_HISTORY] = setThreadHasHistory, _createReducer[Types.UPDATE_REACTION_DATA] = updateReactionData, _createReducer[Types.UPDATE_NOTIFY_DETAILS] = updateNotifyDetails, _createReducer));
export default Creators;