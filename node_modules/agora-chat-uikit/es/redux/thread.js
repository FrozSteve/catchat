var _createReducer;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { createReducer, createActions } from "reduxsauce";
import Immutable from "seamless-immutable";
import _ from "lodash";
import AppDB from '../utils/AppDB';
import MessageActions from "./message";
import WebIM from "../utils/WebIM";
import { message } from '../EaseChat/common/alert';
import i18next from "i18next";
/* ------------- Initial State ------------- */

export var INITIAL_STATE = Immutable({
  showThread: true,
  //thread entry
  hasThreadEditPanel: false,
  threadPanelStates: false,
  //show thread panel
  threadList: [],
  threadListCursor: '',
  //Tag for request thread list
  threadListEnd: false,
  //Are all data requested
  isCreatingThread: false,
  //Whether it is creating thread
  currentThreadInfo: {},
  threadOriginalMsg: {},
  curGroupRole: {},
  //currentGrouprole 'admin' 'member' 'owner'
  threadListPanelDisplay: false //show thread panel

});
/* ------------- Types and Action Creators ------------- */

var _createActions = createActions({
  setShowThread: ["status"],
  updateThreadStates: ["options"],
  setThreadList: ["threadList", "isScroll"],
  setIsCreatingThread: ['status'],
  setCurrentThreadInfo: ['message'],
  setThreadOriginalMsg: ['message'],
  setThreadListCursor: ['cursor'],
  setThreadListEnd: ['status'],
  setCurGroupRole: ['options'],
  setHasThreadEditPanel: ['status'],
  setThreadListPanelDisplay: ['status'],
  getCurrentGroupRole: function getCurrentGroupRole(options) {
    return function (dispatch) {
      var sessionType = options.sessionType,
          sessionId = options.sessionId;
      if (sessionType !== "groupChat") return;
      var groupId = sessionId;
      var rootState = uikit_store.getState();

      var _$get = _.get(rootState, ['global', 'globalProps']),
          username = _$get.username;

      WebIM.conn.getGroupInfo({
        groupId: groupId
      }).then(function (res) {
        var role = 'member';
        var data = res.data ? res.data[0] : {};

        if (data.id === groupId && data.owner === username) {
          if (data.owner === username) {
            role = 'owner';
            dispatch(Creators.setCurGroupRole(role));
          }
        } else {
          WebIM.conn.getGroupAdmin({
            groupId: groupId
          }).then(function (res) {
            if (res.data.indexOf(username) > -1) {
              role = 'admin';
            }

            dispatch(Creators.setCurGroupRole(role));
          });
        }
      });
    };
  },
  getThreadsListOfGroup: function getThreadsListOfGroup(options) {
    return function (dispatch) {
      var rootState = uikit_store.getState();

      var _$get2 = _.get(rootState, ['thread']),
          threadListEnd = _$get2.threadListEnd,
          curGroupRole = _$get2.curGroupRole,
          threadListCursor = _$get2.threadListCursor;

      if (threadListEnd) return;
      var getThreadFun = curGroupRole === 'member' ? 'getJoinedChatThreads' : 'getChatThreads';
      var paramsData = {
        parentId: options.groupId,
        pageSize: options.limit
      };
      options.isScroll ? paramsData.cursor = threadListCursor : null;
      WebIM.conn[getThreadFun](paramsData).then(function (res) {
        var threadList = res.entities;

        if (threadList.length === 0) {
          dispatch(Creators.setThreadListEnd(true));

          if (!options.isScroll) {
            dispatch(Creators.setThreadList(threadList, options.isScroll));
          }

          return;
        }

        dispatch(Creators.setThreadListCursor(res.properties.cursor));
        var chatThreadIds = threadList.map(function (item) {
          return item.id;
        });
        WebIM.conn.getChatThreadLastMessage({
          chatThreadIds: chatThreadIds
        }).then(function (res) {
          var msgList = res.entities;
          threadList.forEach(function (item) {
            var found = msgList.find(function (msgInfo) {
              return item.id === msgInfo.chatThreadId;
            });
            item.lastMessage = found && found.lastMessage ? found.lastMessage : {};
          });
          dispatch(Creators.setThreadList(threadList, options.isScroll));
        })["catch"](function () {
          dispatch(Creators.setThreadList(threadList, options.isScroll));
        });
      });
    };
  },
  updateThreadInfo: function updateThreadInfo(options) {
    return function (dispatch) {
      var rootState = uikit_store.getState();
      var _rootState$thread = rootState.thread,
          currentThreadInfo = _rootState$thread.currentThreadInfo,
          threadOriginalMsg = _rootState$thread.threadOriginalMsg;
      var operation = options.operation,
          messageId = options.messageId;
      var groupChat = rootState['message']['groupChat'];
      var chatThreadOverview = {};

      if (operation === 'userRemove' || operation === 'destroy') {
        chatThreadOverview = undefined;
      } else if (operation === 'create' || operation === 'update') {
        chatThreadOverview = Object.assign({}, options, {
          source: 'notify'
        });
      } //handle the threadPanel and warn


      //handle the threadPanel and warn
      if ((operation === 'userRemove' || operation === 'destroy') && (currentThreadInfo === null || currentThreadInfo === void 0 ? void 0 : currentThreadInfo.id) === options.id) {
        dispatch(Creators.updateThreadStates(false));
        dispatch(Creators.setCurrentThreadInfo({}));
        var warnText = operation === 'userRemove' ? i18next.t('You have been removed from the thread') : i18next.t('The thread has been disbanded');
        message.warn(warnText);
      } else if (currentThreadInfo.id === options.id || threadOriginalMsg.id === options.messageId) {
        var info = currentThreadInfo.asMutable({
          deep: true
        }); //othrer create the chatThread of the message

        //othrer create the chatThread of the message
        if (operation === 'create') {
          if (WebIM.conn.context.userId !== options.operator) {
            dispatch(Creators.updateThreadStates(false));
            dispatch(Creators.setCurrentThreadInfo({}));
            dispatch(Creators.setThreadOriginalMsg({}));
            message.warn(i18next.t('Someone else created a thread for this message'));
          } else {
            //create 事件下发时间大部分晚于update，收到create不处理，防止覆盖 messageCount 字段
            if (!info.timestamp) {
              //update the owner
              dispatch(Creators.setCurrentThreadInfo(Object.assign({}, info, {
                owner: chatThreadOverview.operator
              })));
            }
          }
        }

        if (operation === 'update') {
          dispatch(Creators.setCurrentThreadInfo(Object.assign({}, info, chatThreadOverview, {
            owner: chatThreadOverview.operator
          })));
        }

        dispatch(Creators.setIsCreatingThread(false));
      } //update Local database


      //update Local database
      AppDB.findLocalMessage('groupChat', messageId).then(function (res) {
        var msg = res.length === 1 ? res[0] : {};
        var info = msg.chatThreadOverview && chatThreadOverview ? msg.chatThreadOverview : {}; //create 事件下发时间大部分晚于update，收到create不处理，防止覆盖 messageCount 字段

        //create 事件下发时间大部分晚于update，收到create不处理，防止覆盖 messageCount 字段
        if (operation === 'destroy') {
          AppDB.updateMessageThread(messageId, undefined);
        } else if (operation !== 'create' || operation === 'create' && !info.timestamp) {
          AppDB.updateMessageThread(messageId, Object.assign({}, info, chatThreadOverview));
        }
      }); //handler messageList

      //handler messageList
      if (groupChat && groupChat[options.parentId]) {
        var messageList = _.get(groupChat, [options.parentId]).asMutable({
          deep: true
        });

        messageList.forEach(function (msg) {
          if (msg.id === messageId) {
            var _info = msg.chatThreadOverview && chatThreadOverview ? msg.chatThreadOverview : {};

            if (operation === 'destroy') {
              msg.chatThreadOverview = undefined;
            } else if (operation !== 'create' || operation === 'create' && !_info.timestamp) {
              msg.chatThreadOverview = Object.assign({}, _info, chatThreadOverview);
            }
          }
        });
        dispatch(MessageActions.updateThreadDetails('groupChat', options, messageList));
      } //update threadList


      //update threadList
      var threadList = _.get(rootState, ['thread', 'threadList'], Immutable([])).asMutable();

      var found = _.find(threadList, {
        id: options.id
      });

      if (!found) return;

      if (operation === 'update') {
        var newThread = _extends({}, found, {
          name: options.name
        });

        options.last_message ? newThread.last_message = options.last_message : null;
        threadList.splice(threadList.indexOf(found), 1, newThread);
      } else {
        // 'threadUpdated' 'threadDestroyed'  'threadUserRemoved';
        threadList.splice(threadList.indexOf(found), 1);
      }

      dispatch(Creators.setThreadList(threadList));
    };
  },
  //thread member received changed
  updateMultiDeviceEvent: function updateMultiDeviceEvent(msg) {
    return function (dispatch) {
      var rootState = uikit_store.getState();
      var currentThreadInfo = rootState.thread.currentThreadInfo;

      if (msg.operation === 'chatThreadLeave' && (currentThreadInfo === null || currentThreadInfo === void 0 ? void 0 : currentThreadInfo.id) === msg.chatThreadId) {
        dispatch(Creators.updateThreadStates(false));
      }
    };
  }
}),
    Types = _createActions.Types,
    Creators = _createActions.Creators;
/* ------------- Reducers ------------- */


export var setThreadMessage = function setThreadMessage(state, _ref) {
  var theadId = _ref.theadId,
      message = _ref.message;
  var data = state[threadMessage][theadId] ? state[threadMessage][theadId].asMutable() : [];
  data = data.concat(message);
  return state.setIn([threadMessage, theadId], data);
};
export var setShowThread = function setShowThread(state, _ref2) {
  var status = _ref2.status;
  return state.setIn(["showThread"], status);
};
export var updateThreadStates = function updateThreadStates(state, _ref3) {
  var options = _ref3.options;
  return state.setIn(["threadPanelStates"], options);
};
export var setThreadList = function setThreadList(state, _ref4) {
  var threadList = _ref4.threadList,
      isScroll = _ref4.isScroll;
  var data = state['threadList'].asMutable();
  data = data.concat(threadList);

  if (isScroll) {
    state = state.setIn(['threadList'], data);
  } else {
    state = state.setIn(['threadList'], threadList);
  }

  return state;
};
export var setIsCreatingThread = function setIsCreatingThread(state, _ref5) {
  var status = _ref5.status;
  return state.merge({
    isCreatingThread: status
  });
};
export var setCurrentThreadInfo = function setCurrentThreadInfo(state, _ref6) {
  var message = _ref6.message;
  return state.merge({
    currentThreadInfo: message
  });
};
export var setThreadOriginalMsg = function setThreadOriginalMsg(state, _ref7) {
  var message = _ref7.message;
  return state.merge({
    threadOriginalMsg: message
  });
};
export var setThreadListCursor = function setThreadListCursor(state, _ref8) {
  var cursor = _ref8.cursor;
  return state.setIn(['threadListCursor'], cursor);
};
export var setThreadListEnd = function setThreadListEnd(state, _ref9) {
  var status = _ref9.status;
  return state.setIn(['threadListEnd'], status);
};
export var setCurGroupRole = function setCurGroupRole(state, _ref10) {
  var options = _ref10.options;
  return state.setIn(['curGroupRole'], options);
};
export var setHasThreadEditPanel = function setHasThreadEditPanel(state, _ref11) {
  var status = _ref11.status;
  return state.setIn(['hasThreadEditPanel'], status);
};
export var setThreadListPanelDisplay = function setThreadListPanelDisplay(state, _ref12) {
  var status = _ref12.status;
  return state.setIn(['threadListPanelDisplay'], status);
};
/* ------------- Hookup Reducers To Types ------------- */

export var threadReducer = createReducer(INITIAL_STATE, (_createReducer = {}, _createReducer[Types.SET_SHOW_THREAD] = setShowThread, _createReducer[Types.UPDATE_THREAD_STATES] = updateThreadStates, _createReducer[Types.SET_THREAD_LIST] = setThreadList, _createReducer[Types.SET_IS_CREATING_THREAD] = setIsCreatingThread, _createReducer[Types.SET_CURRENT_THREAD_INFO] = setCurrentThreadInfo, _createReducer[Types.SET_THREAD_ORIGINAL_MSG] = setThreadOriginalMsg, _createReducer[Types.SET_THREAD_LIST_CURSOR] = setThreadListCursor, _createReducer[Types.SET_THREAD_LIST_END] = setThreadListEnd, _createReducer[Types.SET_CUR_GROUP_ROLE] = setCurGroupRole, _createReducer[Types.SET_HAS_THREAD_EDIT_PANEL] = setHasThreadEditPanel, _createReducer[Types.SET_THREAD_LIST_PANEL_DISPLAY] = setThreadListPanelDisplay, _createReducer));
export default Creators;