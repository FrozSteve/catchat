"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(require("react"));

var _SettingsVoice = _interopRequireDefault(require("@material-ui/icons/SettingsVoice"));

var _Stop = _interopRequireDefault(require("@material-ui/icons/Stop"));

var _core = require("@material-ui/core");

var _styles = require("@material-ui/styles");

var _message = _interopRequireDefault(require("../../../redux/message"));

var _reactRedux = require("react-redux");

var _recordAudio = _interopRequireDefault(require("./recorder/recordAudio"));

var _WebIM = _interopRequireDefault(require("../../../utils/WebIM"));

var _i18next = _interopRequireDefault(require("i18next"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var useStyles = (0, _styles.makeStyles)(function (theme) {
  return {
    container: {
      width: "300px",
      overflowX: "hidden",
      padding: "10px",
      "& canvas": {
        width: "300px !important"
      }
    },
    start: {
      color: "#23C381",
      border: "1px solid"
    },
    stop: {
      color: "red",
      border: "1px solid"
    },
    tipText: {
      textAlign: 'center',
      color: '#727272',
      marginBottom: '20px'
    }
  };
});
var MediaStream;

function Recorder(_ref) {
  var open = _ref.open,
      onClose = _ref.onClose,
      isChatThread = _ref.isChatThread,
      threadName = _ref.threadName;
  var classes = useStyles();
  var dispatch = (0, _reactRedux.useDispatch)();

  var _useState = (0, _react.useState)(""),
      status = _useState[0],
      setStatus = _useState[1];

  var _useState2 = (0, _react.useState)(60),
      num = _useState2[0],
      setNum = _useState2[1];

  var _useState3 = (0, _react.useState)({}),
      recorderObj = _useState3[0],
      setRecorderObj = _useState3[1];

  var _useState4 = (0, _react.useState)(""),
      timeInterval = _useState4[0],
      setTimeInterval = _useState4[1];

  var _useState5 = (0, _react.useState)(""),
      startTime = _useState5[0],
      setStartTime = _useState5[1];

  var currentThreadInfo = (0, _reactRedux.useSelector)(function (state) {
    var _state$thread;

    return (_state$thread = state.thread) === null || _state$thread === void 0 ? void 0 : _state$thread.currentThreadInfo;
  });
  var threadOriginalMsg = (0, _reactRedux.useSelector)(function (state) {
    var _state$thread2;

    return (_state$thread2 = state.thread) === null || _state$thread2 === void 0 ? void 0 : _state$thread2.threadOriginalMsg;
  });
  var isCreatingThread = (0, _reactRedux.useSelector)(function (state) {
    var _state$thread3;

    return (_state$thread3 = state.thread) === null || _state$thread3 === void 0 ? void 0 : _state$thread3.isCreatingThread;
  });
  var mounted;
  (0, _react.useEffect)(function () {
    mounted = true;
    return function () {
      mounted = false;
      clearInterval(timeInterval);
    };
  }, []);
  var globalProps = (0, _reactRedux.useSelector)(function (state) {
    return state.global.globalProps;
  });
  var to = globalProps.to,
      chatType = globalProps.chatType;

  var handleClose = function handleClose() {
    if (status === "recording") {
      setStatus("inactive");
    }

    onClose();
  };

  var clearTimer = function clearTimer() {
    if (timeInterval) {
      setNum(60);
      clearInterval(timeInterval);
    }
  }; // start recorder


  var mouseStart = function mouseStart(e) {
    e.preventDefault();
    e.stopPropagation();
    setStatus("recording");

    var _startTime = new Date().getTime();

    setStartTime(_startTime);
    clearTimer();

    _recordAudio["default"].get(function (rec, val) {
      setRecorderObj(rec);
      console.log('recrecrecrecrec', rec, val.getTracks());
      MediaStream = val;

      if (rec) {
        var _interval = setInterval(function () {
          if (num <= 0 && mounted) {
            rec.stop();
            setNum(60);
            clearTimer();
          } else {
            var n = num - 1;
            setNum(n);
            rec.start();
          }
        }, 1000);

        setTimeInterval(_interval);
      }
    });
  }; // end recorder


  var mouseEnd = function mouseEnd(type) {
    return function (e) {
      e.preventDefault();
      e.stopPropagation();
      setStatus("inactive");
      clearTimer();

      var _endTime = new Date().getTime();

      var duration = (_endTime - startTime) / 1000;

      if (recorderObj) {
        console.log('recorderObj>>', _recordAudio["default"]);
        recorderObj.stop(); // 重置说话时间

        setNum(60); // 获取语音二进制文件

        var blob = recorderObj.getBlob(); // 发送语音功能

        if (type === "audio") {
          var uri = {
            url: _WebIM["default"].utils.parseDownloadResponse.call(_WebIM["default"].conn, blob),
            filename: "audio-message.wav",
            filetype: "audio",
            data: blob,
            length: duration,
            duration: duration
          };
          createChatThread().then(function (to) {
            dispatch(_message["default"].sendRecorder(to, chatType, uri, isChatThread));
          });
          onClose();
          MediaStream.getTracks()[0].stop();
        }
      }
    };
  };

  var createChatThread = function createChatThread() {
    return new Promise(function (resolve, reject) {
      if (isCreatingThread && isChatThread) {
        if (!threadName) {
          console.log('threadName can not empty');
          return;
        }

        var options = {
          name: threadName.replace(/(^\s*)|(\s*$)/g, ""),
          messageId: threadOriginalMsg.id,
          parentId: threadOriginalMsg.to
        };

        _WebIM["default"].conn.createChatThread(options).then(function (res) {
          var _res$data;

          var threadId = (_res$data = res.data) === null || _res$data === void 0 ? void 0 : _res$data.chatThreadId;
          resolve(threadId);
        });
      } else if (isChatThread) {
        resolve(currentThreadInfo.id);
      } else {
        resolve(to);
      }
    });
  };

  return /*#__PURE__*/_react["default"].createElement(_core.Dialog, {
    onClose: handleClose,
    "aria-labelledby": "simple-dialog-title",
    open: open
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.container
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.tipText
  }, _i18next["default"].t("Click to start recording")), /*#__PURE__*/_react["default"].createElement("div", {
    style: {
      textAlign: "center"
    }
  }, status !== "recording" && /*#__PURE__*/_react["default"].createElement(_core.IconButton, {
    className: classes.start,
    onClick: mouseStart
  }, /*#__PURE__*/_react["default"].createElement(_SettingsVoice["default"], null)), status === "recording" && /*#__PURE__*/_react["default"].createElement(_core.IconButton, {
    className: classes.stop,
    onClick: mouseEnd("audio")
  }, /*#__PURE__*/_react["default"].createElement(_Stop["default"], null)))));
}

var _default = (0, _react.memo)(Recorder);

exports["default"] = _default;
module.exports = exports.default;